<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nicolas Brosse">
<meta name="dcterms.date" content="2026-01-18">
<meta name="description" content="Analyzing Raman spectra with machine learning approaches.">

<title>Analyzing Raman Spectra with Machine Learning – Nicolas’ Notebook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-75c24fa0c77a874b0ab0aff8b6422dd8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Nicolas’ Notebook</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/nbrosse"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/nicolas-brosse-984685a0/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://scholar.google.com/citations?user=sQ6d5AYAAAAJ&amp;hl"> <i class="bi bi-google" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.researchgate.net/profile/Nicolas-Brosse-3"> <i class="bi bi-r-circle" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Analyzing Raman Spectra with Machine Learning</h1>
                  <div>
        <div class="description">
          Analyzing Raman spectra with machine learning approaches.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">machine learning</div>
                <div class="quarto-category">chemistry</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Nicolas Brosse </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 18, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-raman-overview" id="toc-sec-raman-overview" class="nav-link active" data-scroll-target="#sec-raman-overview">Raman Spectroscopy: An Overview</a>
  <ul class="collapse">
  <li><a href="#introduction-what-is-raman-spectroscopy" id="toc-introduction-what-is-raman-spectroscopy" class="nav-link" data-scroll-target="#introduction-what-is-raman-spectroscopy">Introduction: What is Raman Spectroscopy?</a></li>
  <li><a href="#the-theoretical-principle-of-raman-spectroscopy" id="toc-the-theoretical-principle-of-raman-spectroscopy" class="nav-link" data-scroll-target="#the-theoretical-principle-of-raman-spectroscopy">The Theoretical Principle of Raman Spectroscopy</a>
  <ul class="collapse">
  <li><a href="#molecular-vibrations-degrees-of-freedom" id="toc-molecular-vibrations-degrees-of-freedom" class="nav-link" data-scroll-target="#molecular-vibrations-degrees-of-freedom">Molecular Vibrations &amp; Degrees of Freedom</a></li>
  <li><a href="#vibrational-energy" id="toc-vibrational-energy" class="nav-link" data-scroll-target="#vibrational-energy">Vibrational Energy</a></li>
  <li><a href="#raman-scattering" id="toc-raman-scattering" class="nav-link" data-scroll-target="#raman-scattering">Raman Scattering</a></li>
  <li><a href="#ir-and-raman-active-vibrations" id="toc-ir-and-raman-active-vibrations" class="nav-link" data-scroll-target="#ir-and-raman-active-vibrations">IR and Raman Active Vibrations</a></li>
  <li><a href="#fluorescence-and-raman-scattering" id="toc-fluorescence-and-raman-scattering" class="nav-link" data-scroll-target="#fluorescence-and-raman-scattering">Fluorescence and Raman Scattering</a></li>
  </ul></li>
  <li><a href="#instrumentation-a-raman-spectrometer" id="toc-instrumentation-a-raman-spectrometer" class="nav-link" data-scroll-target="#instrumentation-a-raman-spectrometer">Instrumentation: A Raman Spectrometer</a></li>
  <li><a href="#the-raman-spectrum-interpretation" id="toc-the-raman-spectrum-interpretation" class="nav-link" data-scroll-target="#the-raman-spectrum-interpretation">The Raman Spectrum: Interpretation</a></li>
  <li><a href="#advantages-and-limitations" id="toc-advantages-and-limitations" class="nav-link" data-scroll-target="#advantages-and-limitations">Advantages and Limitations</a>
  <ul class="collapse">
  <li><a href="#advantages" id="toc-advantages" class="nav-link" data-scroll-target="#advantages">Advantages:</a></li>
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations:</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-eda-raman" id="toc-sec-eda-raman" class="nav-link" data-scroll-target="#sec-eda-raman">Exploration and Preprocessing</a>
  <ul class="collapse">
  <li><a href="#sec-preprocessing-raman" id="toc-sec-preprocessing-raman" class="nav-link" data-scroll-target="#sec-preprocessing-raman">Preprocessing Algorithms</a>
  <ul class="collapse">
  <li><a href="#spectral-cropping" id="toc-spectral-cropping" class="nav-link" data-scroll-target="#spectral-cropping">Spectral Cropping</a></li>
  <li><a href="#cosmic-ray-removal-whitaker-hayes" id="toc-cosmic-ray-removal-whitaker-hayes" class="nav-link" data-scroll-target="#cosmic-ray-removal-whitaker-hayes">Cosmic Ray Removal (Whitaker-Hayes)</a></li>
  <li><a href="#denoising-savitzky-golay" id="toc-denoising-savitzky-golay" class="nav-link" data-scroll-target="#denoising-savitzky-golay">Denoising (Savitzky-Golay)</a></li>
  <li><a href="#baseline-correction-aspls" id="toc-baseline-correction-aspls" class="nav-link" data-scroll-target="#baseline-correction-aspls">Baseline Correction (ASPLS)</a></li>
  <li><a href="#complete-preprocessing-pipeline" id="toc-complete-preprocessing-pipeline" class="nav-link" data-scroll-target="#complete-preprocessing-pipeline">Complete Preprocessing Pipeline</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-ml-raman" id="toc-sec-ml-raman" class="nav-link" data-scroll-target="#sec-ml-raman">Machine Learning Approaches</a>
  <ul class="collapse">
  <li><a href="#sec-pls-canonical" id="toc-sec-pls-canonical" class="nav-link" data-scroll-target="#sec-pls-canonical">PLS Canonical (PLSW2A) Algorithm</a>
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#algorithm" id="toc-algorithm" class="nav-link" data-scroll-target="#algorithm">Algorithm</a></li>
  <li><a href="#matrix-decompositions" id="toc-matrix-decompositions" class="nav-link" data-scroll-target="#matrix-decompositions">Matrix Decompositions</a></li>
  <li><a href="#rotation-matrices" id="toc-rotation-matrices" class="nav-link" data-scroll-target="#rotation-matrices">Rotation Matrices</a></li>
  <li><a href="#prediction-mapping-x-to-y" id="toc-prediction-mapping-x-to-y" class="nav-link" data-scroll-target="#prediction-mapping-x-to-y">Prediction: Mapping <span class="math inline">\(X\)</span> to <span class="math inline">\(Y\)</span></a></li>
  <li><a href="#summary-table-1" id="toc-summary-table-1" class="nav-link" data-scroll-target="#summary-table-1">Summary Table</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-notebooks"><h2>Notebooks</h2><ul><li><a href="notebooks/_eda-preview.html"><i class="bi bi-journal-code"></i>Raman Challenge Dataset Analysis</a></li><li><a href="notebooks/_ml-preview.html"><i class="bi bi-journal-code"></i>Raman Challenge: Machine Learning Model for Concentration Prediction</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>This blog post is inspired by an interview homework and a Kaggle competition. The objective is to provide an overview of Raman spectroscopy and provide some ML approaches to analyze Raman spectra. The associated code is available on GitHub at <a href="https://github.com/nbrosse/raman-spectra">raman-spectra</a>.</p>
<p>In the first part, <a href="#sec-raman-overview" class="quarto-xref">Section&nbsp;1</a>, we review the physical principles underlying Raman scattering, the distinction between Stokes and anti-Stokes lines, the relationship between Raman and IR selection rules, and the main components of a Raman spectrometer.</p>
<p>The second part, <a href="#sec-eda-raman" class="quarto-xref">Section&nbsp;2</a>, uses the Dig4Bio Raman Transfer Learning Challenge dataset as a concrete example. Through the accompanying notebook, we perform a brief exploratory data analysis and motivate the need for a robust preprocessing pipeline when working with real-world spectra from multiple instruments. The dedicated section <a href="#sec-preprocessing-raman" class="quarto-xref">Section&nbsp;2.3</a> then details the individual steps of this pipeline—spectral cropping, Whitaker–Hayes cosmic-ray removal, Savitzky–Golay denoising, and ASPLS baseline correction—both conceptually and mathematically, following their implementation in RamanSPy.</p>
<p>The third part <a href="#sec-ml-raman" class="quarto-xref">Section&nbsp;3</a>, focuses on predicting analyte concentrations from preprocessed spectra. We start with a classical chemometrics baseline using PLS Canonical (PLSW2A), reviewing the underlying algorithm, the geometry of scores, loadings, and rotation matrices, and how these pieces assemble into a linear map from spectra to concentrations. The goal is to provide a transparent, end-to-end example of a supervised learning pipeline—from raw spectra, through preprocessing, to a calibrated regression model.</p>
<p>Finally, the <a href="https://github.com/nbrosse/raman-spectra">accompanying codebase</a> extends beyond traditional PLS models and includes an experimental transformer-based toolkit, SpecBERT, for spectral analysis. SpecBERT adapts BERT/ViT-style encoders to 1D Raman spectra, using Masked Spectral Modeling (MSM) for self-supervised pretraining on large unlabeled spectral collections, followed by supervised fine-tuning for regression or classification. This implementation is intentionally labeled as experimental: it was largely generated with AI assistance as a proof of concept and should be treated as a starting point rather than production-ready software. Nevertheless, it illustrates how modern representation-learning techniques can complement classical chemometric methods when spectral data are abundant but accurate concentration labels are scarce.</p>
<section id="sec-raman-overview" class="level1">
<h1>Raman Spectroscopy: An Overview</h1>
<p>This section provides an overview of Raman spectroscopy, including the theoretical principle, instrumentation, and interpretation of the Raman spectrum. The main source is the Wikipedia article <span class="citation" data-cites="wikipedia-raman-spectroscopy">(<a href="#ref-wikipedia-raman-spectroscopy" role="doc-biblioref">Wikipedia contributors 2025</a>)</span>.</p>
<section id="introduction-what-is-raman-spectroscopy" class="level2">
<h2 class="anchored" data-anchor-id="introduction-what-is-raman-spectroscopy">Introduction: What is Raman Spectroscopy?</h2>
<p>Raman Spectroscopy is a non-destructive analytical technique used to observe vibrational, rotational, and other low-frequency modes in a system. It provides a structural “fingerprint” by which molecules can be identified and characterized.</p>
<p>The technique is named after Indian physicist Sir C. V. Raman, who, along with his student K. S. Krishnan, discovered the phenomenon in 1928, earning Raman the Nobel Prize in Physics in 1930.</p>
<p>At its core, Raman spectroscopy relies on the <strong>inelastic scattering of monochromatic light</strong>, usually from a laser. When light interacts with a molecule, most of it is scattered at the same energy (and wavelength) as the incident light. This is called <strong>Rayleigh Scattering</strong>. However, a tiny fraction of the light (about 1 in 10 million photons) is scattered at a different energy. This inelastic scattering is the <strong>Raman Effect</strong>, and the energy difference provides the chemical and structural information.</p>
<p>We illustrate a Raman spectrum in <a href="#fig-raman-spectrum-example" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div id="fig-raman-spectrum-example" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Raman spectrum plot showing intensity versus Raman shift, with labeled peaks corresponding to glucose, sodium acetate, and magnesium sulfate.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-raman-spectrum-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/raman-spectrum-example.png" class="img-fluid figure-img" alt="Raman spectrum plot showing intensity versus Raman shift, with labeled peaks corresponding to glucose, sodium acetate, and magnesium sulfate.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-raman-spectrum-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Example Raman spectrum from the Kaiser dataset showing characteristic peaks for glucose, sodium acetate, and magnesium sulfate. Peak locations are based on literature values. Sample concentrations: glucose 10.59 g/L, sodium acetate 1.11 g/L, and magnesium sulfate 3.48 g/L. <span class="citation" data-cites="LANGE2025125861">(<a href="#ref-LANGE2025125861" role="doc-biblioref">Lange et al. 2025, fig. 1</a>)</span>
</figcaption>
</figure>
</div>
</section>
<section id="the-theoretical-principle-of-raman-spectroscopy" class="level2">
<h2 class="anchored" data-anchor-id="the-theoretical-principle-of-raman-spectroscopy">The Theoretical Principle of Raman Spectroscopy</h2>
<section id="molecular-vibrations-degrees-of-freedom" class="level3">
<h3 class="anchored" data-anchor-id="molecular-vibrations-degrees-of-freedom">Molecular Vibrations &amp; Degrees of Freedom</h3>
<p>Molecules are not static. Their atoms are constantly in motion, and these motions can be categorized. Raman spectroscopy is a tool to measure the energy of one specific type of motion: <strong>vibration</strong>.</p>
<ul>
<li><strong>Degrees of Freedom (<span class="math inline">\(3N\)</span>):</strong> For a molecule with <span class="math inline">\(N\)</span> atoms, each atom can move independently in three dimensions <span class="math inline">\((x, y, z)\)</span>. This gives a total of <span class="math inline">\(3N\)</span> possible movements for the entire molecule.</li>
<li><strong>Partitioning the Motion:</strong> These <span class="math inline">\(3N\)</span> motions are not all vibrations. They are a combination of:
<ol type="1">
<li><strong>Translational Motion (3 degrees):</strong> The entire molecule moving as a single unit through space (up/down, left/right, forward/backward). This accounts for <span class="math inline">\(3\)</span> of the <span class="math inline">\(3N\)</span> motions.</li>
<li><strong>Rotational Motion (2 or 3 degrees):</strong> The entire molecule spinning around its center of mass. For a <strong>non-linear molecule</strong> it accounts for another <span class="math inline">\(3\)</span> motions, and for a <strong>linear molecule</strong> it accounts for <span class="math inline">\(2\)</span> motions.</li>
<li><strong>Vibrational Motion (The Remainder):</strong> Any motion that is left over is an internal vibration—the stretching, bending, twisting, or rocking of the chemical bonds themselves.
<ul>
<li><strong>Number of Vibrational Modes for a non-linear molecule = <span class="math inline">\(3N - 6\)</span></strong></li>
<li><strong>Number of Vibrational Modes for a linear molecule = <span class="math inline">\(3N - 5\)</span></strong></li>
</ul></li>
</ol></li>
</ul>
<p>This simple calculation tells a scientist the theoretical number of fundamental vibrations a molecule has, which helps in interpreting a complex spectrum by knowing how many peaks to look for.</p>
</section>
<section id="vibrational-energy" class="level3">
<h3 class="anchored" data-anchor-id="vibrational-energy">Vibrational Energy</h3>
<p>The energy associated with molecular vibrations is <strong>quantized</strong>. A vibrating bond cannot have <em>any</em> arbitrary amount of energy. It can only exist at discrete energy levels, like the rungs of a ladder.</p>
<ul>
<li><strong>Quantum Harmonic Oscillator (QHO):</strong> This is a simplified physical model used to describe these energy levels. The formula <span class="math inline">\(E_n = h(n + 1/2)\nu\)</span> describes the energy of each level, where <span class="math inline">\(n\)</span> is the quantum number (0, 1, 2…), <span class="math inline">\(h\)</span> is Planck’s constant, and <span class="math inline">\(\nu\)</span> is the natural frequency of the vibration. This frequency depends on the strength of the bond and the mass of the atoms.</li>
<li><strong>Energy Change:</strong> Raman spectroscopy doesn’t measure the absolute energy of a level (<span class="math inline">\(E_n\)</span>), but rather the <strong>energy difference</strong> required to jump from one level to another (typically from <span class="math inline">\(n=0\)</span> to <span class="math inline">\(n=1\)</span>). This energy difference, <span class="math inline">\(\Delta E = h\nu\)</span>, is what we see as a peak in the spectrum, reported as a <strong>Raman Shift</strong> in wavenumbers (<span class="math inline">\(cm^{-1}\)</span>).</li>
</ul>
</section>
<section id="raman-scattering" class="level3">
<h3 class="anchored" data-anchor-id="raman-scattering">Raman Scattering</h3>
<p>This is the core of the Raman effect, explaining the interaction between light and the molecule that produces the signal. When a laser photon strikes a molecule, it pushes the molecule into an unstable, extremely short-lived “virtual state.” The molecule immediately relaxes from this state by emitting a new photon.</p>
<p>Three things can happen:</p>
<ol type="1">
<li><strong>Rayleigh Scattering (Elastic):</strong> The molecule relaxes back to the <em>exact same</em> vibrational energy level it started from. The emitted photon has the <strong>exact same energy</strong> as the incident laser photon. This is the most common event by far and contains no chemical information.</li>
<li><strong>Stokes Raman Scattering (Inelastic):</strong> The molecule starts in the ground state (<span class="math inline">\(n=0\)</span>), is excited to the virtual state, and then relaxes to a <em>higher</em> vibrational level (<span class="math inline">\(n=1\)</span>). Because the molecule has absorbed energy, the emitted photon must have <strong>less energy</strong> than the incident photon. The energy difference corresponds exactly to the vibrational energy <span class="math inline">\(h\nu\)</span>. This is the signal we typically measure as it is most intense.</li>
<li><strong>Anti-Stokes Raman Scattering (Inelastic):</strong> The molecule starts in an already excited vibrational state (<span class="math inline">\(n=1\)</span>), is excited to the virtual state, and then relaxes down to the ground state (<span class="math inline">\(n=0\)</span>). The molecule has lost energy, so the emitted photon has <strong>more energy</strong> than the incident photon.</li>
</ol>
<p>At room temperature, the vast majority of molecules are in the ground state, as described by the <strong>Boltzmann distribution</strong>. Therefore, <strong>Stokes peaks are always significantly more intense (stronger) than Anti-Stokes peaks.</strong></p>
</section>
<section id="ir-and-raman-active-vibrations" class="level3">
<h3 class="anchored" data-anchor-id="ir-and-raman-active-vibrations">IR and Raman Active Vibrations</h3>
<p>This section explains the “rules” that determine whether a specific vibration will produce a Raman signal. This is the critical difference between Raman and Infrared (IR) spectroscopy.</p>
<ul>
<li><strong>The Raman Rule - Change in Polarizability:</strong> A vibration is “Raman active” only if it causes a <strong>change in the molecule’s polarizability</strong>. Polarizability is a measure of how easily the electron cloud of a molecule can be distorted by an external electric field (like that of the laser).</li>
<li><strong>The IR Rule - Change in Dipole Moment:</strong> A vibration is “IR active” only if it causes a <strong>change in the molecule’s dipole moment</strong>.</li>
</ul>
<p>This difference leads to complementarity:</p>
<ul>
<li>Symmetric vibrations (e.g., C-C, S-S) often cause large changes in polarizability. They are <strong>strong in Raman but weak or absent in IR.</strong></li>
<li>Asymmetric vibrations involving polar bonds (e.g., C=O) cause large changes in dipole moment. They are <strong>strong in IR but may be weak in Raman.</strong></li>
<li>For molecules with a center of symmetry (like CO₂), the <strong>Rule of Mutual Exclusion</strong> states that a vibration cannot be both IR and Raman active.</li>
</ul>
<p>To fully grasp this, we summarize the differences between dipole moment and polarizability in the table below.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 41%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th><strong>Dipole Moment (μ)</strong></th>
<th><strong>Polarizability (α)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Nature</strong></td>
<td>Intrinsic, permanent property</td>
<td>Induced, response property</td>
</tr>
<tr class="even">
<td><strong>Origin</strong></td>
<td>Unequal sharing of electrons (electronegativity difference)</td>
<td>Distortion of electron cloud by an external electric field</td>
</tr>
<tr class="odd">
<td><strong>Existence</strong></td>
<td>Exists even without an external field</td>
<td>Describes the potential to be distorted; distortion occurs only in a field</td>
</tr>
<tr class="even">
<td><strong>Analogy</strong></td>
<td>A permanent magnet</td>
<td>The “squishiness” of a ball</td>
</tr>
<tr class="odd">
<td><strong>Key Example</strong></td>
<td><strong>H₂O</strong> is polar (large dipole moment).</td>
<td><strong>Benzene</strong> is non-polar (zero dipole moment) but highly polarizable.</td>
</tr>
<tr class="even">
<td><strong>Spectroscopy Rule</strong></td>
<td><strong>Change in Dipole Moment</strong> during vibration -&gt; <strong>IR Active</strong></td>
<td><strong>Change in Polarizability</strong> during vibration -&gt; <strong>Raman Active</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="fluorescence-and-raman-scattering" class="level3">
<h3 class="anchored" data-anchor-id="fluorescence-and-raman-scattering">Fluorescence and Raman Scattering</h3>
<p>Fluorescence and Raman scattering are both optical phenomena that involve the interaction of light with matter, but they differ fundamentally in their mechanisms and the information they provide.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 40%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th><strong>Raman Scattering</strong></th>
<th><strong>Fluorescence</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Mechanism</strong></td>
<td><strong>Scattering</strong> process involving a “virtual state.”</td>
<td><strong>Absorption-Emission</strong> process involving real electronic states.</td>
</tr>
<tr class="even">
<td><strong>Timescale</strong></td>
<td>Virtually instantaneous (~femtoseconds)</td>
<td>Delayed by nanoseconds (fluorescence lifetime)</td>
</tr>
<tr class="odd">
<td><strong>Energy Shift</strong></td>
<td><strong>Small, specific shifts</strong> (Raman Shifts) corresponding to <em>vibrational</em> energies.</td>
<td><strong>Large, broad shift</strong> (Stokes Shift) corresponding to the energy gap between <em>electronic</em> states.</td>
</tr>
<tr class="even">
<td><strong>Information Provided</strong></td>
<td>A sharp “fingerprint” of specific molecular vibrations.</td>
<td>A broad signal indicating the presence of a fluorescent molecule.</td>
</tr>
<tr class="odd">
<td><strong>Efficiency / Intensity</strong></td>
<td><strong>Extremely Inefficient</strong> (1 in 10⁷ photons) -&gt; <strong>Very Weak Signal</strong></td>
<td><strong>Very Efficient</strong> (can be &gt;90%) -&gt; <strong>Extremely Strong Signal</strong></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="instrumentation-a-raman-spectrometer" class="level2">
<h2 class="anchored" data-anchor-id="instrumentation-a-raman-spectrometer">Instrumentation: A Raman Spectrometer</h2>
<p>A Raman spectrometer is designed to isolate and detect the extremely weak Raman scattered light from the overwhelmingly strong Rayleigh scattered light.</p>
<p>The essential components are:</p>
<ol type="1">
<li><strong>Light Source (Laser):</strong> A powerful, stable, monochromatic light source. Common lasers include Visible (e.g., 532 nm, 633 nm) and Near-Infrared (NIR) (e.g., 785 nm, 1064 nm) which reduces fluorescence.</li>
<li><strong>Sample Illumination and Collection Optics:</strong> Lenses or microscope objectives focus the laser onto the sample and collect the scattered light. In <strong>micro-Raman spectroscopy</strong>, this allows analysis of areas down to ~1 micron.</li>
<li><strong>Optical Filter (Notch or Edge Filter):</strong> The most critical component. It blocks the intense Rayleigh scattered light while allowing the Stokes and/or Anti-Stokes light to pass through.</li>
<li><strong>Dispersive Element (Spectrograph):</strong> A <strong>diffraction grating</strong> separates the Raman signal into its constituent wavelengths.</li>
<li><strong>Detector:</strong> A highly sensitive detector, almost universally a <strong>Charge-Coupled Device (CCD)</strong> camera, is used to detect the weak signal and capture the entire spectrum at once.</li>
</ol>
</section>
<section id="the-raman-spectrum-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="the-raman-spectrum-interpretation">The Raman Spectrum: Interpretation</h2>
<p>The output from the spectrometer is a Raman spectrum, see for example the spectrum in <a href="#fig-raman-spectrum-example" class="quarto-xref">Figure&nbsp;1</a>.</p>
<ul>
<li><strong>X-axis:</strong> <strong>Raman Shift (<span class="math inline">\(cm^{-1}\)</span>)</strong>. This corresponds to the vibrational frequency (energy) of molecular bonds. A key advantage is that the Raman shift is independent of the laser wavelength used.</li>
<li><strong>Y-axis:</strong> <strong>Intensity (Arbitrary Units)</strong>. This is proportional to the concentration of the molecule and how “Raman active” that particular vibration is.</li>
</ul>
<p>Each peak in the spectrum corresponds to a specific molecular vibration.</p>
<ul>
<li><strong>Fingerprint Region (approx. 400 - 1800 <span class="math inline">\(cm^{-1}\)</span>):</strong> This region is rich with peaks from various bending and stretching modes. The complex pattern is unique to each molecule, making it a “molecular fingerprint” for identification.</li>
<li><strong>Functional Group Region (approx. 1800 - 4000 <span class="math inline">\(cm^{-1}\)</span>):</strong> This region contains peaks from specific functional groups, such as C-H stretches (~2800-3100 <span class="math inline">\(cm^{-1}\)</span>), C≡C triple bonds (~2100-2300 <span class="math inline">\(cm^{-1}\)</span>), and O-H stretches (~3200-3600 <span class="math inline">\(cm^{-1}\)</span>).</li>
</ul>
</section>
<section id="advantages-and-limitations" class="level2">
<h2 class="anchored" data-anchor-id="advantages-and-limitations">Advantages and Limitations</h2>
<section id="advantages" class="level3">
<h3 class="anchored" data-anchor-id="advantages">Advantages:</h3>
<ul>
<li><strong>Non-Destructive:</strong> Uses low-power light and typically does not damage the sample.</li>
<li><strong>Minimal Sample Preparation:</strong> Can analyze solids, liquids, and gases directly, often through containers.</li>
<li><strong>Water is a Weak Scatterer:</strong> Excellent for analyzing biological or aqueous samples, a major advantage over IR.</li>
<li><strong>High Spatial Resolution:</strong> Micro-Raman can provide chemical information on a micron scale.</li>
<li><strong>Specificity:</strong> Provides a sharp, well-resolved “fingerprint” spectrum for unambiguous identification.</li>
<li><strong>Remote &amp; In-situ Analysis:</strong> Can be coupled with fiber optics for remote monitoring.</li>
</ul>
</section>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations:</h3>
<ul>
<li><strong>Weak Signal:</strong> The Raman effect is inherently inefficient, sometimes requiring long acquisition times.</li>
<li><strong>Fluorescence Interference:</strong> The most significant challenge. Fluorescence from the sample can overwhelm the weak Raman signal. This is often mitigated by using NIR lasers (e.g., 785 nm).</li>
<li><strong>Sample Heating:</strong> High-intensity lasers can heat or burn sensitive samples.</li>
<li><strong>Not Ideal for Metals:</strong> Cannot be used for elemental analysis of metals as they lack molecular bonds.</li>
</ul>
</section>
</section>
</section>
<section id="sec-eda-raman" class="level1">
<h1>Exploration and Preprocessing</h1>
<p>Since the data of the interview homework is not publicly available, we will use the dataset from the Kaggle competition <span class="citation" data-cites="dig-4-bio-raman-transfer-learning-challenge">(<a href="#ref-dig-4-bio-raman-transfer-learning-challenge" role="doc-biblioref">Hassfurther 2025</a>)</span> to illustrate some machine learning approaches to Raman spectroscopy. This dataset and the Kaggle competition are inspired by the article <span class="citation" data-cites="LANGE2025125861">(<a href="#ref-LANGE2025125861" role="doc-biblioref">Lange et al. 2025</a>)</span> which compares machine learning methods on Raman spectra from eight different spectrometers.</p>
<p>Note that we do not follow the extensive analysis of the article <span class="citation" data-cites="LANGE2025125861">(<a href="#ref-LANGE2025125861" role="doc-biblioref">Lange et al. 2025</a>)</span> but rather focus on some simple machine learning approaches to analyze the Raman spectra that we implemented for the interview homework. We use the Python package <span class="citation" data-cites="georgiev2024ramanspy">(<a href="#ref-georgiev2024ramanspy" role="doc-biblioref">Georgiev et al. 2024</a>)</span> to analyze the Raman spectra.</p>
<p>We first present a notebook that contains an exploration of the dataset and some preprocessing algorithms. The preprocessing algorithms are presented and explained in <a href="#sec-preprocessing-raman" class="quarto-xref">Section&nbsp;2.3</a>.</p>
<div class="quarto-embed-nb-cell">
<section id="raman-challenge-dataset-analysis" class="level2">
<h2 class="anchored" data-anchor-id="raman-challenge-dataset-analysis">Raman Challenge Dataset Analysis</h2>
<p>This notebook analyzes the dig-4-bio-raman transfer learning challenge dataset and demonstrates how to load and work with the multi-instrument Raman spectroscopy data.</p>
<div id="c666486d9737ba2c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;ExecuteTime&quot;,&quot;value&quot;:{&quot;end_time&quot;:&quot;2025-06-30T09:12:39.062386Z&quot;,&quot;start_time&quot;:&quot;2025-06-30T09:12:38.236205Z&quot;}}" data-execution_count="17">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Literal</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.express <span class="im">as</span> px</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ramanspy <span class="im">as</span> rp</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span><span class="pp">SyntaxWarning</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="ad3cdf34675b32de" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;ExecuteTime&quot;,&quot;value&quot;:{&quot;end_time&quot;:&quot;2025-06-30T09:12:39.507927Z&quot;,&quot;start_time&quot;:&quot;2025-06-30T09:12:39.504163Z&quot;}}" data-execution_count="18">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">Define common paths and preprocessing pipelines.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">This section sets up:</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">- Data directory path</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">- Standard preprocessing pipeline (without normalization)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">  - Cropping to fingerprint region (300-1942 cm⁻¹)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">  - Cosmic ray removal (Whitaker-Hayes)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">  - Denoising (Savitzky-Golay filter)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">  - Baseline correction (ASPLS)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">Note: Normalization is commented out as it can destroy concentration information</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">for regression tasks.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Data directory path</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>data_path <span class="op">=</span> Path(<span class="st">"../data/dig-4-bio-raman-transfer-learning-challenge"</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Fingerprint region</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>MIN_WAVENUMBER <span class="op">=</span> <span class="dv">300</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>MAX_WAVENUMBER <span class="op">=</span> <span class="dv">1942</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard preprocessing pipeline without normalization</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co"># This pipeline is suitable for regression tasks where we want to preserve</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># concentration-related intensity information</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>standard_pipeline_without_normalisation <span class="op">=</span> rp.preprocessing.Pipeline([</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.misc.Cropper(region<span class="op">=</span>(MIN_WAVENUMBER, MAX_WAVENUMBER)),  <span class="co"># Fingerprint region</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.despike.WhitakerHayes(),          <span class="co"># Remove cosmic rays</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.denoise.SavGol(window_length<span class="op">=</span><span class="dv">9</span>, polyorder<span class="op">=</span><span class="dv">3</span>),  <span class="co"># Smooth noise</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.baseline.ASPLS(),                 <span class="co"># Remove baseline drift</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rp.preprocessing.normalise.MinMax()  # Excluded for regression tasks</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="7b4a7266" class="cell" data-execution_count="19">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">Utility functions</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_spectral_columns(df: pd.DataFrame) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">list</span>[<span class="bu">str</span>], <span class="bu">list</span>[<span class="bu">str</span>], np.ndarray]:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Identifies spectral data columns by checking if the column name can be converted to a float.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    This is a robust way to separate metadata from spectral data.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    spectral_cols <span class="op">=</span> []</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    metadata_cols <span class="op">=</span> []</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">float</span>(col)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            spectral_cols.append(col)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> (<span class="pp">ValueError</span>, <span class="pp">TypeError</span>):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            metadata_cols.append(col)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    wavenumbers <span class="op">=</span> pd.to_numeric(spectral_cols)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> metadata_cols, spectral_cols, wavenumbers</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_background_subtraction_pipeline(background: rp.Spectrum) <span class="op">-&gt;</span> rp.preprocessing.Pipeline:</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Builds a background subtraction pipeline with a specified region for cropping.</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    background <span class="op">=</span> rp.preprocessing.misc.Cropper(region<span class="op">=</span>(MIN_WAVENUMBER, MAX_WAVENUMBER)).<span class="bu">apply</span>(background)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rp.preprocessing.Pipeline([</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        rp.preprocessing.misc.Cropper(region<span class="op">=</span>(MIN_WAVENUMBER, MAX_WAVENUMBER)),</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        rp.preprocessing.misc.BackgroundSubtractor(background<span class="op">=</span>background)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    ])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="dataset-description" class="level3">
<h3 class="anchored" data-anchor-id="dataset-description">Dataset Description</h3>
<p>This dataset contains Raman spectra from <strong>8 different instruments</strong> measuring samples with known concentrations of three analytes:</p>
<ul>
<li><strong>Glucose</strong> (g/L)</li>
<li><strong>Sodium Acetate</strong> (Na_acetate, g/L)</li>
<li><strong>Magnesium Sulfate</strong> (Mg_SO4, g/L)</li>
</ul>
<p>The instruments included are: Anton 532, Anton 785, Kaiser, Metrohm, Mettler Toledo, Tec 5, Timegate, and Tornado.</p>
<p><strong>Measurement Protocol:</strong></p>
<ul>
<li>All samples were measured at room temperature with instrument-specific exposure times</li>
<li>Most instruments acquired 5 replicate spectra per sample; Kaiser and Timegate recorded a single spectrum per sample</li>
<li>Due to varying instrument availability, the sample sets differ across spectrometers</li>
</ul>
<p><strong>Instrument Characteristics:</strong> Each instrument exhibits unique properties that must be accounted for in analysis:</p>
<ul>
<li><strong>Wavenumber ranges</strong>: Vary from ~200 to ~3500 cm⁻¹ across instruments</li>
<li><strong>Spectral resolution</strong>: Differs between instruments</li>
</ul>
<p>Let’s start by loading data from one instrument (anton_532) to understand the data structure and visualize a sample spectrum.</p>
<div id="4b2c8fb8" class="cell" data-execution_count="20">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">Load and visualize a sample spectrum from the anton_532 instrument.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">This demonstrates:</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">1. Loading CSV data with spectral columns (wavenumbers) and metadata</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">2. Separating spectral data from metadata</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">3. Creating a RamanSPy SpectralContainer for analysis</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">4. Visualizing a raw spectrum with its concentration information</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data from anton_532 instrument</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(data_path <span class="op">/</span> <span class="st">"anton_532.csv"</span>).drop(columns<span class="op">=</span>[<span class="st">"MSM_present"</span>, <span class="st">"fold_idx"</span>])</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate spectral columns (numeric column names = wavenumbers) from metadata</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>metadata_cols, spectral_cols, wavenumbers <span class="op">=</span> find_spectral_columns(df)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Create RamanSPy SpectralContainer for easier manipulation</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>spectral_container <span class="op">=</span> rp.SpectralContainer(</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    spectral_data<span class="op">=</span>df[spectral_cols].values,</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    spectral_axis<span class="op">=</span>wavenumbers</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Select first spectrum for visualization</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>spectrum <span class="op">=</span> spectral_container[<span class="dv">0</span>]</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> df[metadata_cols].iloc[<span class="dv">0</span>].to_dict()</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Create informative title with concentration information</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>title <span class="op">=</span> (</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Original Spectrum - "</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"glucose </span><span class="sc">{</span>metadata[<span class="st">'glucose'</span>]<span class="sc">:.4f}</span><span class="ss"> g/L - "</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Na_acetate </span><span class="sc">{</span>metadata[<span class="st">'Na_acetate'</span>]<span class="sc">:.4f}</span><span class="ss"> g/L - "</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Mg_SO4 </span><span class="sc">{</span>metadata[<span class="st">'Mg_SO4'</span>]<span class="sc">:.4f}</span><span class="ss"> g/L"</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the spectrum</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>rp.plot.spectra(spectra<span class="op">=</span>[spectrum], plot_type<span class="op">=</span><span class="st">"single"</span>, title<span class="op">=</span>title)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>rp.plot.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="data-structure-overview" class="level3">
<h3 class="anchored" data-anchor-id="data-structure-overview">Data Structure Overview</h3>
<p>Let’s examine the structure of the loaded dataset to understand how the data is organized. The DataFrame contains:</p>
<ul>
<li><strong>Metadata columns</strong>: Concentration values (glucose, Na_acetate, Mg_SO4) and other sample information</li>
<li><strong>Spectral columns</strong>: Numeric column names representing wavenumber values (cm⁻¹)</li>
<li>Each row represents a single spectrum measurement with its associated concentration metadata</li>
</ul>
<div id="4c6e1511" class="cell" data-execution_count="21">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the first few rows of the dataset</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>df.head(<span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">200.0</th>
<th data-quarto-table-cell-role="th">202.0</th>
<th data-quarto-table-cell-role="th">204.0</th>
<th data-quarto-table-cell-role="th">206.0</th>
<th data-quarto-table-cell-role="th">208.0</th>
<th data-quarto-table-cell-role="th">210.0</th>
<th data-quarto-table-cell-role="th">212.0</th>
<th data-quarto-table-cell-role="th">214.0</th>
<th data-quarto-table-cell-role="th">216.0</th>
<th data-quarto-table-cell-role="th">218.0</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">3488.0</th>
<th data-quarto-table-cell-role="th">3490.0</th>
<th data-quarto-table-cell-role="th">3492.0</th>
<th data-quarto-table-cell-role="th">3494.0</th>
<th data-quarto-table-cell-role="th">3496.0</th>
<th data-quarto-table-cell-role="th">3498.0</th>
<th data-quarto-table-cell-role="th">3500.0</th>
<th data-quarto-table-cell-role="th">glucose</th>
<th data-quarto-table-cell-role="th">Na_acetate</th>
<th data-quarto-table-cell-role="th">Mg_SO4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>7519.06</td>
<td>7582.15</td>
<td>7379.73</td>
<td>7054.04</td>
<td>6818.64</td>
<td>6684.24</td>
<td>6562.20</td>
<td>6398.03</td>
<td>6256.17</td>
<td>6135.72</td>
<td>...</td>
<td>6539.65</td>
<td>6475.20</td>
<td>6573.45</td>
<td>6488.44</td>
<td>6284.99</td>
<td>6216.51</td>
<td>6409.21</td>
<td>0.26335</td>
<td>1.4357</td>
<td>1.44101</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>7414.24</td>
<td>7502.98</td>
<td>7327.93</td>
<td>7002.97</td>
<td>6760.01</td>
<td>6638.17</td>
<td>6539.84</td>
<td>6360.47</td>
<td>6200.67</td>
<td>6080.42</td>
<td>...</td>
<td>6507.23</td>
<td>6451.34</td>
<td>6564.97</td>
<td>6465.79</td>
<td>6241.37</td>
<td>6171.89</td>
<td>6358.46</td>
<td>0.26335</td>
<td>1.4357</td>
<td>1.44101</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>7376.45</td>
<td>7474.90</td>
<td>7304.00</td>
<td>6961.46</td>
<td>6691.31</td>
<td>6557.30</td>
<td>6470.64</td>
<td>6309.66</td>
<td>6177.40</td>
<td>6090.05</td>
<td>...</td>
<td>6501.41</td>
<td>6432.22</td>
<td>6521.16</td>
<td>6452.89</td>
<td>6248.68</td>
<td>6137.06</td>
<td>6318.74</td>
<td>0.26335</td>
<td>1.4357</td>
<td>1.44101</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>7383.60</td>
<td>7456.90</td>
<td>7264.59</td>
<td>6938.71</td>
<td>6707.66</td>
<td>6594.61</td>
<td>6493.20</td>
<td>6307.50</td>
<td>6144.74</td>
<td>6033.89</td>
<td>...</td>
<td>6498.85</td>
<td>6412.12</td>
<td>6532.58</td>
<td>6459.36</td>
<td>6240.35</td>
<td>6146.15</td>
<td>6325.52</td>
<td>0.26335</td>
<td>1.4357</td>
<td>1.44101</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>7345.77</td>
<td>7435.40</td>
<td>7263.58</td>
<td>6929.82</td>
<td>6671.51</td>
<td>6544.19</td>
<td>6459.28</td>
<td>6302.71</td>
<td>6158.40</td>
<td>6043.02</td>
<td>...</td>
<td>6506.29</td>
<td>6414.26</td>
<td>6530.51</td>
<td>6435.62</td>
<td>6214.08</td>
<td>6156.26</td>
<td>6348.95</td>
<td>0.26335</td>
<td>1.4357</td>
<td>1.44101</td>
</tr>
</tbody>
</table>

<p>5 rows × 1654 columns</p>
</div>
</div>
</div>
</section>
<section id="step-by-step-preprocessing-visualization" class="level3">
<h3 class="anchored" data-anchor-id="step-by-step-preprocessing-visualization">Step-by-Step Preprocessing Visualization</h3>
<p>Preprocessing is crucial for Raman spectroscopy data analysis. Raw spectra contain:</p>
<ul>
<li><strong>Baseline drift</strong>: Broad fluorescence background</li>
<li><strong>Cosmic rays</strong>: Sharp spikes from detector artifacts</li>
<li><strong>Noise</strong>: Random measurement noise</li>
<li><strong>Edge effects</strong>: Instrument-specific artifacts at spectral edges</li>
</ul>
<p>This section visualizes how each preprocessing step transforms the spectrum, helping us understand the impact of each operation. We apply the following steps:</p>
<ul>
<li><strong>Cropping</strong>: Remove edge artifacts and focus on fingerprint region (300-1942 cm⁻¹)</li>
<li><strong>Cosmic Ray Removal</strong>: Remove sharp spikes (Whitaker-Hayes algorithm)</li>
<li><strong>Denoising</strong>: Smooth the spectrum (Savitzky-Golay filter)</li>
<li><strong>Baseline Correction</strong>: Remove broad fluorescence background (ASPLS)</li>
</ul>
<p>This visualization helps understand how each preprocessing step improves signal quality and prepares the data for analysis.</p>
<div id="5d170e6f" class="cell" data-execution_count="22">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(data_path <span class="op">/</span> <span class="st">"anton_532.csv"</span>).drop( columns<span class="op">=</span>[<span class="st">"MSM_present"</span>, <span class="st">"fold_idx"</span>])</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>metadata_cols, spectral_cols, wavenumbers <span class="op">=</span> find_spectral_columns(df)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>spectral_container <span class="op">=</span> rp.SpectralContainer(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    spectral_data<span class="op">=</span>df[spectral_cols].values,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    spectral_axis<span class="op">=</span>wavenumbers</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>spectrum <span class="op">=</span> spectral_container[<span class="dv">0</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> df[metadata_cols].iloc[<span class="dv">0</span>].to_dict()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>title <span class="op">=</span> <span class="ss">f"Original Spectrum - glucose </span><span class="sc">{</span>metadata[<span class="st">'glucose'</span>]<span class="sc">:.4f}</span><span class="ss"> gL - Na_acetate </span><span class="sc">{</span>metadata[<span class="st">'Na_acetate'</span>]<span class="sc">:.4f}</span><span class="ss"> gL - Mg_SO4 </span><span class="sc">{</span>metadata[<span class="st">'Mg_SO4'</span>]<span class="sc">:.4f}</span><span class="ss"> gL"</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>rp.plot.spectra(spectra<span class="op">=</span>[spectrum], plot_type<span class="op">=</span><span class="st">"single"</span>, title<span class="op">=</span>title)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>rp.plot.show()</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> step <span class="kw">in</span> standard_pipeline_without_normalisation:</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    spectrum <span class="op">=</span> step.<span class="bu">apply</span>(spectrum)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    title <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>step<span class="sc">.</span><span class="va">__class__</span><span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">"</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    rp.plot.spectra([spectrum], plot_type<span class="op">=</span><span class="st">"single"</span>, title<span class="op">=</span>title)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    rp.plot.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-7-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-7-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-7-output-4.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-7-output-5.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="understanding-spectral-cropping" class="level3">
<h3 class="anchored" data-anchor-id="understanding-spectral-cropping">Understanding Spectral Cropping</h3>
<p>From the visualization above, we can observe:</p>
<ul>
<li><strong>Wavenumber range</strong>: Approximately 300–3600 cm⁻¹</li>
<li><strong>Strong baseline/fluorescence</strong>: Broad curvature from background fluorescence</li>
<li><strong>Edge artifacts</strong>:
<ul>
<li>Below ~450 cm⁻¹: Edge effects, Rayleigh tail, optical artifacts</li>
<li>Above ~3000 cm⁻¹: OH stretch from water dominates the signal</li>
</ul></li>
<li><strong>Chemically informative region</strong>: The fingerprint region (400–1800 cm⁻¹) contains the most relevant information</li>
</ul>
<p>The reference paper <a href="https://doi.org/10.1016/j.saa.2025.125861">Comparing machine learning methods on Raman spectra from eight different spectrometers</a> recommends:</p>
<ul>
<li><strong>Crop to 300–1942 cm⁻¹</strong>: The largest common range across all 8 instruments</li>
<li><strong>Rationale</strong>:
<ul>
<li>Preserves glucose, acetate, and MgSO₄ peaks</li>
<li>Removes high-wavenumber water OH stretch</li>
<li>Eliminates instrument-specific edge artifacts</li>
<li>Improves cross-device robustness for transfer learning</li>
</ul></li>
</ul>
<p>For this dataset, cropping to <strong>300–1942 cm⁻¹</strong> is justified because:</p>
<ul>
<li><strong>Glucose peaks</strong>: ~800–1150 cm⁻¹ ✓</li>
<li><strong>Acetate peak</strong>: ~920 cm⁻¹ ✓</li>
<li><strong>MgSO₄ strong peak</strong>: ~980 cm⁻¹ ✓</li>
<li><strong>Minimal water interference</strong>: Removes dominant OH stretch region</li>
<li><strong>Better signal-to-noise</strong>: Focuses on chemically informative region</li>
</ul>
<p>This region contains the most relevant information for quantitative analysis while removing noise and artifacts.</p>
</section>
<section id="sample-structure-and-organization" class="level3">
<h3 class="anchored" data-anchor-id="sample-structure-and-organization">Sample Structure and Organization</h3>
<p>The dataset is organized around <strong>unique concentration triplets</strong> defined by the three analytes:</p>
<ul>
<li><strong>Glucose</strong> (g/L)</li>
<li><strong>Sodium Acetate</strong> (Na_acetate, g/L)</li>
<li><strong>Magnesium Sulfate</strong> (Mg_SO4, g/L)</li>
</ul>
<p><strong>Replication Structure:</strong></p>
<ul>
<li>Most instruments (Anton 532, Anton 785, Metrohm, Mettler Toledo, Tec 5, Tornado) recorded <strong>at least 5 replicate spectra</strong> per unique concentration triplet</li>
<li><strong>Kaiser and Timegate instruments</strong> recorded only <strong>1 spectrum per concentration triplet</strong> (no replicates)</li>
</ul>
<p><strong>Sample Numbering:</strong> To facilitate analysis and visualization, we assign a unique <code>sample_number</code> to each distinct concentration triplet. This allows us to:</p>
<ul>
<li>Group spectra by their concentration profile</li>
<li>Select representative spectra from each unique sample</li>
<li>Track how preprocessing affects spectra from the same sample across different replicates</li>
</ul>
</section>
<section id="exploring-concentration-distribution" class="level3">
<h3 class="anchored" data-anchor-id="exploring-concentration-distribution">Exploring Concentration Distribution</h3>
<p>Let’s examine the distribution of unique concentration triplets in the dataset. This helps us understand:</p>
<ul>
<li>How many unique samples (concentration combinations) are present</li>
<li>The frequency of each concentration triplet</li>
<li>The overall structure of the experimental design</li>
</ul>
<div id="81048a91" class="cell" data-execution_count="23">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>df_metadata <span class="op">=</span> df[metadata_cols]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df_metadata[[<span class="st">"glucose"</span>, <span class="st">"Na_acetate"</span>, <span class="st">"Mg_SO4"</span>]].value_counts()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>glucose   Na_acetate  Mg_SO4  
0.00000   0.00000     0.000000    10
                      0.022899     5
                      1.483750     5
                      3.490220     5
          0.01612     0.005016     5
          0.38593     0.023827     5
          0.65286     0.046091     5
          0.71544     1.567450     5
          0.75931     0.017697     5
          0.76773     3.945410     5
          1.29106     0.000000     5
          1.37442     1.355800     5
          1.39750     3.308900     5
0.24955   0.08245     3.454390     5
0.25369   0.00000     0.022609     5
0.25636   0.67294     0.005511     5
0.25649   0.74089     3.345560     5
0.25787   0.00000     0.000000     5
0.26229   0.03709     1.494600     5
0.26335   1.43570     1.441010     5
0.27710   0.69733     1.441180     5
0.28256   1.33788     0.035751     5
0.29784   1.56128     3.348590     5
0.49945   1.33009     0.003688     5
0.51645   1.02701     1.328620     5
0.52096   0.00000     0.015037     5
0.52616   0.00000     1.396560     5
0.53269   0.68172     0.056479     5
0.56078   1.07925     3.139890     5
0.79631   1.06674     3.090570     5
1.02342   0.71756     1.557450     5
1.18537   0.00000     2.948570     5
4.56573   0.69828     1.541520     5
4.62097   0.97254     0.014210     5
4.63261   0.69969     0.022235     5
4.73407   0.67310     0.003497     5
4.77883   0.00000     0.023272     5
4.78962   1.03913     1.497530     5
4.87666   0.72635     3.073870     5
4.91288   1.03532     3.302040     5
5.12832   0.02430     1.715070     5
5.24672   0.02440     3.361270     5
6.39311   0.00000     0.024451     5
10.16120  0.00000     1.477840     5
10.28120  0.66554     0.000000     5
10.35390  0.00000     0.000000     5
10.39640  0.68902     1.602520     5
10.59310  1.11418     3.484130     5
10.65220  0.00000     2.620210     5
10.66050  1.13599     1.624690     5
10.71080  0.74408     3.480790     5
10.74480  1.05836     0.005669     5
16.73440  0.00000     0.022216     5
Name: count, dtype: int64</code></pre>
</div>
</div>
</section>
<section id="assigning-sample-numbers" class="level3">
<h3 class="anchored" data-anchor-id="assigning-sample-numbers">Assigning Sample Numbers</h3>
<p>To facilitate analysis, we assign a unique <code>sample_number</code> to each distinct concentration triplet. This allows us to:</p>
<ul>
<li>Group all replicate spectra from the same sample together</li>
<li>Easily select representative spectra for visualization</li>
<li>Track samples across different preprocessing steps</li>
</ul>
<p>After assignment, we sort the DataFrame by <code>sample_number</code> to organize the data for easier analysis.</p>
<div id="54a306a6" class="cell" data-execution_count="24">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'sample_number'</span>] <span class="op">=</span> df.groupby([<span class="st">'glucose'</span>, <span class="st">'Na_acetate'</span>, <span class="st">'Mg_SO4'</span>]).ngroup()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="2861004b" class="cell" data-execution_count="25">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.sort_values(by<span class="op">=</span><span class="st">"sample_number"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">200.0</th>
<th data-quarto-table-cell-role="th">202.0</th>
<th data-quarto-table-cell-role="th">204.0</th>
<th data-quarto-table-cell-role="th">206.0</th>
<th data-quarto-table-cell-role="th">208.0</th>
<th data-quarto-table-cell-role="th">210.0</th>
<th data-quarto-table-cell-role="th">212.0</th>
<th data-quarto-table-cell-role="th">214.0</th>
<th data-quarto-table-cell-role="th">216.0</th>
<th data-quarto-table-cell-role="th">218.0</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">3490.0</th>
<th data-quarto-table-cell-role="th">3492.0</th>
<th data-quarto-table-cell-role="th">3494.0</th>
<th data-quarto-table-cell-role="th">3496.0</th>
<th data-quarto-table-cell-role="th">3498.0</th>
<th data-quarto-table-cell-role="th">3500.0</th>
<th data-quarto-table-cell-role="th">glucose</th>
<th data-quarto-table-cell-role="th">Na_acetate</th>
<th data-quarto-table-cell-role="th">Mg_SO4</th>
<th data-quarto-table-cell-role="th">sample_number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">48</th>
<td>7872.51</td>
<td>7949.13</td>
<td>7756.47</td>
<td>7430.07</td>
<td>7191.07</td>
<td>7054.33</td>
<td>6923.01</td>
<td>6728.96</td>
<td>6566.42</td>
<td>6446.71</td>
<td>...</td>
<td>8358.85</td>
<td>8459.03</td>
<td>8365.43</td>
<td>8120.00</td>
<td>7994.58</td>
<td>8164.45</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000000</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">47</th>
<td>7855.57</td>
<td>7937.75</td>
<td>7754.15</td>
<td>7431.91</td>
<td>7196.21</td>
<td>7069.05</td>
<td>6947.50</td>
<td>6745.40</td>
<td>6582.47</td>
<td>6474.62</td>
<td>...</td>
<td>8294.69</td>
<td>8415.91</td>
<td>8343.10</td>
<td>8109.79</td>
<td>7992.89</td>
<td>8171.26</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000000</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">46</th>
<td>7880.69</td>
<td>7968.58</td>
<td>7784.68</td>
<td>7442.57</td>
<td>7186.43</td>
<td>7063.44</td>
<td>6968.17</td>
<td>6777.16</td>
<td>6612.35</td>
<td>6503.68</td>
<td>...</td>
<td>8341.36</td>
<td>8440.34</td>
<td>8340.85</td>
<td>8101.21</td>
<td>7993.53</td>
<td>8176.15</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000000</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">49</th>
<td>7816.74</td>
<td>7903.64</td>
<td>7718.65</td>
<td>7384.09</td>
<td>7142.29</td>
<td>7031.14</td>
<td>6940.11</td>
<td>6749.42</td>
<td>6575.63</td>
<td>6450.89</td>
<td>...</td>
<td>8321.98</td>
<td>8416.93</td>
<td>8310.16</td>
<td>8071.10</td>
<td>7973.64</td>
<td>8140.15</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000000</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">45</th>
<td>7927.66</td>
<td>8014.66</td>
<td>7817.07</td>
<td>7476.43</td>
<td>7234.11</td>
<td>7111.39</td>
<td>6999.47</td>
<td>6808.78</td>
<td>6644.33</td>
<td>6525.25</td>
<td>...</td>
<td>8359.07</td>
<td>8461.60</td>
<td>8376.35</td>
<td>8146.79</td>
<td>8041.58</td>
<td>8224.00</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000000</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">197</th>
<td>8207.04</td>
<td>8318.43</td>
<td>8149.32</td>
<td>7811.73</td>
<td>7548.74</td>
<td>7407.86</td>
<td>7296.73</td>
<td>7115.31</td>
<td>6970.95</td>
<td>6873.25</td>
<td>...</td>
<td>9045.37</td>
<td>9158.60</td>
<td>9078.45</td>
<td>8841.36</td>
<td>8711.15</td>
<td>8854.53</td>
<td>16.7344</td>
<td>0.0</td>
<td>0.022216</td>
<td>52</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">196</th>
<td>8297.09</td>
<td>8374.05</td>
<td>8181.89</td>
<td>7849.53</td>
<td>7608.91</td>
<td>7486.01</td>
<td>7376.52</td>
<td>7186.54</td>
<td>7024.39</td>
<td>6912.22</td>
<td>...</td>
<td>9154.26</td>
<td>9271.12</td>
<td>9179.31</td>
<td>8934.16</td>
<td>8822.59</td>
<td>8995.83</td>
<td>16.7344</td>
<td>0.0</td>
<td>0.022216</td>
<td>52</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">195</th>
<td>8478.47</td>
<td>8586.03</td>
<td>8417.81</td>
<td>8090.71</td>
<td>7841.44</td>
<td>7706.42</td>
<td>7591.60</td>
<td>7406.22</td>
<td>7241.26</td>
<td>7116.70</td>
<td>...</td>
<td>9541.84</td>
<td>9634.93</td>
<td>9526.42</td>
<td>9289.84</td>
<td>9193.64</td>
<td>9367.68</td>
<td>16.7344</td>
<td>0.0</td>
<td>0.022216</td>
<td>52</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">198</th>
<td>8144.21</td>
<td>8233.26</td>
<td>8056.15</td>
<td>7729.10</td>
<td>7491.60</td>
<td>7380.43</td>
<td>7282.35</td>
<td>7076.46</td>
<td>6901.83</td>
<td>6794.68</td>
<td>...</td>
<td>8967.69</td>
<td>9041.05</td>
<td>8962.62</td>
<td>8754.40</td>
<td>8638.11</td>
<td>8801.52</td>
<td>16.7344</td>
<td>0.0</td>
<td>0.022216</td>
<td>52</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">199</th>
<td>8084.45</td>
<td>8189.22</td>
<td>8040.56</td>
<td>7728.67</td>
<td>7486.21</td>
<td>7363.75</td>
<td>7264.74</td>
<td>7068.97</td>
<td>6883.15</td>
<td>6744.28</td>
<td>...</td>
<td>8949.49</td>
<td>9057.16</td>
<td>8963.22</td>
<td>8726.82</td>
<td>8633.93</td>
<td>8811.21</td>
<td>16.7344</td>
<td>0.0</td>
<td>0.022216</td>
<td>52</td>
</tr>
</tbody>
</table>

<p>270 rows × 1655 columns</p>
</div>
</div>
</div>
</section>
</section>
<section id="comparing-preprocessing-pipelines-standard-vs.-background-subtraction" class="level2">
<h2 class="anchored" data-anchor-id="comparing-preprocessing-pipelines-standard-vs.-background-subtraction">Comparing Preprocessing Pipelines: Standard vs.&nbsp;Background Subtraction</h2>
<p>This section visualizes the effects of different preprocessing pipelines on Raman spectra from various concentrations. We compare two preprocessing approaches:</p>
<ol type="1">
<li><strong>Standard Pipeline</strong>: Applies cropping, cosmic ray removal, denoising, and baseline correction</li>
<li><strong>Background Subtraction Pipeline</strong>: Crops the spectrum and subtracts a reference background spectrum</li>
</ol>
<p><strong>Key Objectives:</strong></p>
<ul>
<li>Understand how different preprocessing methods affect spectral appearance</li>
<li>Compare pipeline performance on spectra from different concentrations</li>
<li>Assess pipeline behavior on replicate spectra from the same concentration</li>
</ul>
<p><strong>Expected Observations:</strong></p>
<ul>
<li><p><strong>Background Subtraction Pipeline</strong>: When applied to spectra from different concentrations, this pipeline produces distinct spectral profiles that clearly differentiate between concentration levels. This demonstrates that the method effectively preserves concentration-dependent signal differences.</p></li>
<li><p><strong>Standard Pipeline</strong>: In contrast, the standard pipeline tends to produce more similar-looking spectra across different concentrations, as it focuses on removing artifacts and noise while preserving the overall spectral shape. This can be beneficial for certain types of analysis but may reduce concentration-dependent signal differences.</p></li>
</ul>
<p><strong>Important Note:</strong> The background subtraction pipeline uses the first spectrum in the dataset as the reference background. For spectra from the same sample (same concentration), this is the first replicate. For spectra from different samples (different concentrations), this corresponds to the first sample in the dataset, which is the zero concentration sample.</p>
<div id="335b762f7bdc6814" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;ExecuteTime&quot;,&quot;value&quot;:{&quot;end_time&quot;:&quot;2025-06-30T09:12:40.341695Z&quot;,&quot;start_time&quot;:&quot;2025-06-30T09:12:40.337547Z&quot;}}" data-execution_count="26">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: Required for exporting static images in Quarto documents.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># (Comment out these lines to enable interactive Plotly plots in Jupyter or other interactive environments.)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.io <span class="im">as</span> pio</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>pio.renderers.default <span class="op">=</span> <span class="st">'png'</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_spectra_interactive(</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    df: pd.DataFrame,</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    pipeline_type: Literal[<span class="st">"standard"</span>, <span class="st">"background"</span>] <span class="op">=</span> <span class="st">"standard"</span>,</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    samples_type: Literal[<span class="st">"same"</span>, <span class="st">"different"</span>] <span class="op">=</span> <span class="st">"same"</span>,</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    height: <span class="bu">int</span> <span class="op">=</span> <span class="dv">800</span>,</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    metadata_cols, spectral_cols, wavenumbers <span class="op">=</span> find_spectral_columns(df)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    spectral_container <span class="op">=</span> rp.SpectralContainer(</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        spectral_data<span class="op">=</span>df[spectral_cols].values,</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        spectral_axis<span class="op">=</span>wavenumbers,</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    fig_title <span class="op">=</span> <span class="ss">f"Plot of </span><span class="sc">{</span>pipeline_type<span class="sc">}</span><span class="ss"> pipeline with </span><span class="sc">{</span>samples_type<span class="sc">}</span><span class="ss"> samples"</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> pipeline_type:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="st">"standard"</span>:</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            spectra_list <span class="op">=</span> standard_pipeline_without_normalisation.<span class="bu">apply</span>(spectral_container)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="st">"background"</span>:</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>            spectra_list <span class="op">=</span> build_background_subtraction_pipeline(background<span class="op">=</span>spectral_container[<span class="dv">0</span>]).<span class="bu">apply</span>(spectral_container)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Series labels</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> samples_type:</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="st">"same"</span>:</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>            series_labels <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(df)))</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="st">"different"</span>:</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>            series_labels <span class="op">=</span> df[[<span class="st">"glucose"</span>, <span class="st">"Na_acetate"</span>, <span class="st">"Mg_SO4"</span>]].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="ss">f"glucose </span><span class="sc">{</span>x[<span class="st">'glucose'</span>]<span class="sc">:.2f}</span><span class="ss"> gL - Na_acetate </span><span class="sc">{</span>x[<span class="st">'Na_acetate'</span>]<span class="sc">:.2f}</span><span class="ss"> gL - Mg_SO4 </span><span class="sc">{</span>x[<span class="st">'Mg_SO4'</span>]<span class="sc">:.2f}</span><span class="ss"> gL"</span>, axis<span class="op">=</span><span class="dv">1</span>).tolist()</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    all_spectra_dfs <span class="op">=</span> []</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, spectrum <span class="kw">in</span> <span class="bu">enumerate</span>(spectra_list):</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        temp_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>            <span class="st">'Wavenumber'</span>: spectrum.spectral_axis,</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>            <span class="st">'Intensity'</span>: spectrum.spectral_data</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>        temp_df[<span class="st">'Series'</span>] <span class="op">=</span> series_labels[i]</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>        all_spectra_dfs.append(temp_df)</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine all the small DataFrames into one large, tidy DataFrame</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    plot_df <span class="op">=</span> pd.concat(all_spectra_dfs, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create the interactive plot</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> px.line(</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>        plot_df,</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span><span class="st">'Wavenumber'</span>,</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span><span class="st">'Intensity'</span>,</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'Series'</span>,          <span class="co"># Each series gets a different color line</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>        title<span class="op">=</span>fig_title,</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>        labels<span class="op">=</span>{                 <span class="co"># Custom labels for axes</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Wavenumber"</span>: <span class="st">"Wavenumber (cm⁻¹)"</span>,</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Intensity"</span>: <span class="st">"Intensity (a.u.)"</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        template<span class="op">=</span><span class="st">'plotly_white'</span>,  <span class="co"># A clean template with grids</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>        height<span class="op">=</span>height,</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update subplot titles to be cleaner (optional)</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[1]))</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Display the figure in the Jupyter Notebook</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>    fig.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="comparing-pipelines-on-different-concentrations" class="level3">
<h3 class="anchored" data-anchor-id="comparing-pipelines-on-different-concentrations">Comparing Pipelines on Different Concentrations</h3>
<p>We first examine how each preprocessing pipeline handles spectra from <strong>different concentration levels</strong>. This helps us understand:</p>
<ul>
<li>How well each pipeline preserves concentration-dependent spectral features</li>
<li>The ability to distinguish between different analyte concentrations</li>
<li>The impact of preprocessing on quantitative signal information</li>
</ul>
<p>We select one representative spectrum from each unique concentration triplet to compare the pipelines on distinct samples.</p>
<div id="51e41d94" class="cell" data-execution_count="27">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>different_samples_df <span class="op">=</span> (</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    df.groupby(<span class="st">"sample_number"</span>, as_index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    .nth(<span class="dv">0</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>different_samples_df.head(<span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">200.0</th>
<th data-quarto-table-cell-role="th">202.0</th>
<th data-quarto-table-cell-role="th">204.0</th>
<th data-quarto-table-cell-role="th">206.0</th>
<th data-quarto-table-cell-role="th">208.0</th>
<th data-quarto-table-cell-role="th">210.0</th>
<th data-quarto-table-cell-role="th">212.0</th>
<th data-quarto-table-cell-role="th">214.0</th>
<th data-quarto-table-cell-role="th">216.0</th>
<th data-quarto-table-cell-role="th">218.0</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">3490.0</th>
<th data-quarto-table-cell-role="th">3492.0</th>
<th data-quarto-table-cell-role="th">3494.0</th>
<th data-quarto-table-cell-role="th">3496.0</th>
<th data-quarto-table-cell-role="th">3498.0</th>
<th data-quarto-table-cell-role="th">3500.0</th>
<th data-quarto-table-cell-role="th">glucose</th>
<th data-quarto-table-cell-role="th">Na_acetate</th>
<th data-quarto-table-cell-role="th">Mg_SO4</th>
<th data-quarto-table-cell-role="th">sample_number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">48</th>
<td>7872.51</td>
<td>7949.13</td>
<td>7756.47</td>
<td>7430.07</td>
<td>7191.07</td>
<td>7054.33</td>
<td>6923.01</td>
<td>6728.96</td>
<td>6566.42</td>
<td>6446.71</td>
<td>...</td>
<td>8358.85</td>
<td>8459.03</td>
<td>8365.43</td>
<td>8120.00</td>
<td>7994.58</td>
<td>8164.45</td>
<td>0.0</td>
<td>0.00000</td>
<td>0.000000</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">27</th>
<td>7867.47</td>
<td>7945.25</td>
<td>7751.45</td>
<td>7424.17</td>
<td>7188.73</td>
<td>7061.26</td>
<td>6942.80</td>
<td>6761.27</td>
<td>6611.74</td>
<td>6500.41</td>
<td>...</td>
<td>8623.98</td>
<td>8714.13</td>
<td>8628.46</td>
<td>8391.91</td>
<td>8265.12</td>
<td>8434.56</td>
<td>0.0</td>
<td>0.00000</td>
<td>0.022899</td>
<td>1</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">207</th>
<td>7342.39</td>
<td>7399.16</td>
<td>7207.68</td>
<td>6881.40</td>
<td>6641.70</td>
<td>6524.32</td>
<td>6434.70</td>
<td>6271.56</td>
<td>6124.36</td>
<td>6011.24</td>
<td>...</td>
<td>7215.12</td>
<td>7326.84</td>
<td>7226.49</td>
<td>6984.68</td>
<td>6873.00</td>
<td>7048.59</td>
<td>0.0</td>
<td>0.00000</td>
<td>1.483750</td>
<td>2</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">84</th>
<td>7405.46</td>
<td>7469.17</td>
<td>7290.53</td>
<td>6987.57</td>
<td>6773.68</td>
<td>6670.61</td>
<td>6572.76</td>
<td>6380.83</td>
<td>6213.01</td>
<td>6102.20</td>
<td>...</td>
<td>7914.66</td>
<td>8002.84</td>
<td>7926.06</td>
<td>7731.41</td>
<td>7653.32</td>
<td>7804.36</td>
<td>0.0</td>
<td>0.00000</td>
<td>3.490220</td>
<td>3</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">190</th>
<td>7344.06</td>
<td>7410.08</td>
<td>7226.07</td>
<td>6909.59</td>
<td>6673.01</td>
<td>6540.97</td>
<td>6424.29</td>
<td>6245.51</td>
<td>6085.45</td>
<td>5962.36</td>
<td>...</td>
<td>6989.71</td>
<td>7082.35</td>
<td>6989.41</td>
<td>6777.86</td>
<td>6697.66</td>
<td>6873.22</td>
<td>0.0</td>
<td>0.01612</td>
<td>0.005016</td>
<td>4</td>
</tr>
</tbody>
</table>

<p>5 rows × 1655 columns</p>
</div>
</div>
</div>
<div id="53cc4c5f" class="cell" data-execution_count="28">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>plot_spectra_interactive(df<span class="op">=</span>different_samples_df, pipeline_type<span class="op">=</span><span class="st">"standard"</span>, samples_type<span class="op">=</span><span class="st">"different"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="4f9109e4" class="cell" data-execution_count="29">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>plot_spectra_interactive(df<span class="op">=</span>different_samples_df, pipeline_type<span class="op">=</span><span class="st">"background"</span>, samples_type<span class="op">=</span><span class="st">"different"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="comparing-pipelines-on-replicate-spectra" class="level3">
<h3 class="anchored" data-anchor-id="comparing-pipelines-on-replicate-spectra">Comparing Pipelines on Replicate Spectra</h3>
<p>Next, we examine how each preprocessing pipeline handles <strong>replicate spectra from the same concentration</strong>. This analysis reveals:</p>
<ul>
<li><strong>Measurement reproducibility</strong>: How consistent are replicate measurements after preprocessing?</li>
<li><strong>Noise characteristics</strong>: What residual variability remains after preprocessing?</li>
<li><strong>Pipeline stability</strong>: How do different preprocessing methods affect replicate consistency?</li>
</ul>
<p>We randomly select one sample (concentration triplet) and visualize all its replicate spectra to assess within-sample variability.</p>
<div id="2ed615be" class="cell" data-execution_count="30">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw a random sample number</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>unique_sample_numbers <span class="op">=</span> df[<span class="st">"sample_number"</span>].unique()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>random_sample_number <span class="op">=</span> np.random.choice(unique_sample_numbers)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>same_samples_df <span class="op">=</span> df[df[<span class="st">"sample_number"</span>] <span class="op">==</span> random_sample_number]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>same_samples_df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">200.0</th>
<th data-quarto-table-cell-role="th">202.0</th>
<th data-quarto-table-cell-role="th">204.0</th>
<th data-quarto-table-cell-role="th">206.0</th>
<th data-quarto-table-cell-role="th">208.0</th>
<th data-quarto-table-cell-role="th">210.0</th>
<th data-quarto-table-cell-role="th">212.0</th>
<th data-quarto-table-cell-role="th">214.0</th>
<th data-quarto-table-cell-role="th">216.0</th>
<th data-quarto-table-cell-role="th">218.0</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">3490.0</th>
<th data-quarto-table-cell-role="th">3492.0</th>
<th data-quarto-table-cell-role="th">3494.0</th>
<th data-quarto-table-cell-role="th">3496.0</th>
<th data-quarto-table-cell-role="th">3498.0</th>
<th data-quarto-table-cell-role="th">3500.0</th>
<th data-quarto-table-cell-role="th">glucose</th>
<th data-quarto-table-cell-role="th">Na_acetate</th>
<th data-quarto-table-cell-role="th">Mg_SO4</th>
<th data-quarto-table-cell-role="th">sample_number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">39</th>
<td>7320.48</td>
<td>7419.34</td>
<td>7262.94</td>
<td>6932.90</td>
<td>6659.87</td>
<td>6511.08</td>
<td>6412.69</td>
<td>6254.91</td>
<td>6114.20</td>
<td>6003.54</td>
<td>...</td>
<td>6505.33</td>
<td>6628.53</td>
<td>6562.14</td>
<td>6346.97</td>
<td>6249.52</td>
<td>6424.52</td>
<td>0.26229</td>
<td>0.03709</td>
<td>1.4946</td>
<td>18</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">37</th>
<td>7406.77</td>
<td>7464.21</td>
<td>7264.81</td>
<td>6934.42</td>
<td>6697.93</td>
<td>6580.23</td>
<td>6468.39</td>
<td>6254.99</td>
<td>6088.88</td>
<td>6006.50</td>
<td>...</td>
<td>6514.41</td>
<td>6650.11</td>
<td>6582.10</td>
<td>6355.25</td>
<td>6250.23</td>
<td>6432.15</td>
<td>0.26229</td>
<td>0.03709</td>
<td>1.4946</td>
<td>18</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">35</th>
<td>7400.97</td>
<td>7517.01</td>
<td>7365.01</td>
<td>7025.82</td>
<td>6752.42</td>
<td>6622.32</td>
<td>6541.35</td>
<td>6361.16</td>
<td>6198.60</td>
<td>6089.23</td>
<td>...</td>
<td>6604.90</td>
<td>6699.57</td>
<td>6597.09</td>
<td>6374.15</td>
<td>6294.01</td>
<td>6489.00</td>
<td>0.26229</td>
<td>0.03709</td>
<td>1.4946</td>
<td>18</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">38</th>
<td>7331.09</td>
<td>7410.65</td>
<td>7238.04</td>
<td>6920.44</td>
<td>6677.50</td>
<td>6547.06</td>
<td>6443.18</td>
<td>6276.78</td>
<td>6130.41</td>
<td>6014.91</td>
<td>...</td>
<td>6526.00</td>
<td>6659.57</td>
<td>6572.41</td>
<td>6339.60</td>
<td>6255.41</td>
<td>6434.59</td>
<td>0.26229</td>
<td>0.03709</td>
<td>1.4946</td>
<td>18</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">36</th>
<td>7386.98</td>
<td>7465.57</td>
<td>7288.87</td>
<td>6969.29</td>
<td>6732.37</td>
<td>6613.17</td>
<td>6507.77</td>
<td>6306.82</td>
<td>6140.97</td>
<td>6039.23</td>
<td>...</td>
<td>6593.39</td>
<td>6661.59</td>
<td>6571.50</td>
<td>6375.59</td>
<td>6293.98</td>
<td>6460.65</td>
<td>0.26229</td>
<td>0.03709</td>
<td>1.4946</td>
<td>18</td>
</tr>
</tbody>
</table>

<p>5 rows × 1655 columns</p>
</div>
</div>
</div>
<div id="33a2e62b" class="cell" data-execution_count="31">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>plot_spectra_interactive(df<span class="op">=</span>same_samples_df, pipeline_type<span class="op">=</span><span class="st">"standard"</span>, samples_type<span class="op">=</span><span class="st">"same"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="85876fc4" class="cell" data-execution_count="32">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>plot_spectra_interactive(df<span class="op">=</span>same_samples_df, pipeline_type<span class="op">=</span><span class="st">"background"</span>, samples_type<span class="op">=</span><span class="st">"same"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_eda-cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="understanding-measurement-variability" class="level3">
<h3 class="anchored" data-anchor-id="understanding-measurement-variability">Understanding Measurement Variability</h3>
<p>The visualization above reveals important insights about measurement variability:</p>
<p><strong>Key Observations:</strong></p>
<ol type="1">
<li><strong>Intrinsic Experimental Variability</strong>: Even with identical sample concentrations, replicate spectra show some variation. This reflects:
<ul>
<li>Natural measurement noise inherent in Raman spectroscopy</li>
<li>Slight variations in sample positioning or laser focus</li>
<li>Instrument-specific measurement characteristics</li>
<li>Environmental factors (temperature, humidity, etc.)</li>
</ul></li>
<li><strong>Pipeline Impact on Variability</strong>:
<ul>
<li>The <strong>standard pipeline</strong> typically reduces variability by removing noise and artifacts, making replicates appear more similar</li>
<li>The <strong>background subtraction pipeline</strong> may preserve or even amplify certain types of variability, depending on the reference background used</li>
</ul></li>
<li><strong>Implications for Analysis</strong>:
<ul>
<li>Understanding this variability is crucial for setting appropriate model expectations</li>
<li>The residual variability after preprocessing represents the lower bound of prediction uncertainty</li>
<li>This information helps in designing robust models that can handle real-world measurement conditions</li>
</ul></li>
</ol>
<p>This variability analysis is essential for developing reliable quantitative models that can generalize to new measurements.</p>
</section>
</section>
<a class="quarto-notebook-link" id="nblink-1" href="notebooks/_eda-preview.html#50a6ff66">Source: Raman Challenge Dataset Analysis</a></div>
<section id="sec-preprocessing-raman" class="level2">
<h2 class="anchored" data-anchor-id="sec-preprocessing-raman">Preprocessing Algorithms</h2>
<p>Raw Raman spectra often contain artifacts and noise that must be addressed before meaningful analysis can be performed. These preprocessing steps are essential for accurate peak identification, quantitative analysis, and machine learning applications. The standard preprocessing pipeline for Raman spectroscopy typically includes: spectral cropping to focus on regions of interest, cosmic ray removal to eliminate detector artifacts, denoising to reduce random noise, and baseline correction to remove fluorescence and drift effects. We describe each of these algorithms below, following the implementations available in RamanSPy <span class="citation" data-cites="georgiev2024ramanspy">(<a href="#ref-georgiev2024ramanspy" role="doc-biblioref">Georgiev et al. 2024</a>)</span>.</p>
<section id="spectral-cropping" class="level3">
<h3 class="anchored" data-anchor-id="spectral-cropping">Spectral Cropping</h3>
<p>The first step in preprocessing is often to reduce the spectral range to the region of interest. For Raman spectroscopy, this typically means focusing on the “fingerprint region” (approximately 400-1800 <span class="math inline">\(cm^{-1}\)</span>) where most characteristic molecular vibrations appear. Cropping serves multiple purposes: it removes noisy edge regions that may contain artifacts, focuses computational resources on the relevant spectral features, and reduces the data size for downstream processing.</p>
<p>The algorithm is straightforward: given a wavenumber axis <span class="math inline">\(w\)</span> and spectrum <span class="math inline">\(s\)</span>, we create a boolean mask and apply it to both:</p>
<p><span class="math display">\[
w_{\text{cropped}} = w[w_{\text{min}} \leq w \leq w_{\text{max}}]
\]</span></p>
<p><span class="math display">\[
s_{\text{cropped}} = s[w_{\text{min}} \leq w \leq w_{\text{max}}]
\]</span></p>
<p>This operation has linear computational complexity <span class="math inline">\(O(n)\)</span> where <span class="math inline">\(n\)</span> is the spectrum length, making it an efficient first step in any preprocessing pipeline.</p>
</section>
<section id="cosmic-ray-removal-whitaker-hayes" class="level3">
<h3 class="anchored" data-anchor-id="cosmic-ray-removal-whitaker-hayes">Cosmic Ray Removal (Whitaker-Hayes)</h3>
<p>Cosmic rays striking the CCD detector during spectral acquisition can produce sharp intensity spikes that are easily mistaken for genuine Raman peaks. The Whitaker-Hayes algorithm <span class="citation" data-cites="WhitakerHayes2018">(<a href="#ref-WhitakerHayes2018" role="doc-biblioref">Whitaker and Hayes 2018</a>)</span> provides a robust method for identifying and removing these artifacts.</p>
<p>The algorithm identifies spikes using <strong>modified z-scores</strong> computed from the first differences of the spectrum. The modified z-score is more robust to outliers than the standard z-score because it uses the median absolute deviation (MAD) instead of the standard deviation:</p>
<p><span class="math display">\[
\text{MAD} = \text{median}(|x_i - \text{median}(x)|)
\]</span></p>
<p><span class="math display">\[
\text{Modified Z-score} = 0.6745 \times \frac{x_i - \text{median}(x)}{\text{MAD}}
\]</span></p>
<p>The constant 0.6745 makes the MAD consistent with the standard deviation for normal distributions. The algorithm examines the first differences of the spectrum:</p>
<p><span class="math display">\[
\Delta s_i = s_{i+1} - s_i
\]</span></p>
<p>Because cosmic rays cause sharp discontinuities, examining differences amplifies these sudden changes while smoothing gradual variations, making spike detection more sensitive than direct intensity analysis.</p>
<p>For each detected spike at position <span class="math inline">\(i\)</span> (where <span class="math inline">\(|z_{\Delta s_i}| &gt; \tau\)</span>, typically <span class="math inline">\(\tau = 8\)</span>), the algorithm iteratively replaces it with the local mean of non-spike neighbors within a kernel of size <span class="math inline">\(k\)</span>:</p>
<p><span class="math display">\[
s'_i =
\begin{cases}
\text{mean}(s_j : j \in N(i), \text{spike}_j = \text{False}) &amp; \text{if spike}_i = \text{True} \\
s_i &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(N(i) = \{\max(0, i-k), \ldots, \min(n-1, i+k)\}\)</span> is the neighborhood around position <span class="math inline">\(i\)</span>.</p>
<p>The algorithm’s robustness comes from its use of median-based statistics, which are resistant to outliers. The iterative nature allows it to handle multiple adjacent spikes, and the local mean replacement preserves peak shapes while removing artifacts.</p>
</section>
<section id="denoising-savitzky-golay" class="level3">
<h3 class="anchored" data-anchor-id="denoising-savitzky-golay">Denoising (Savitzky-Golay)</h3>
<p>Random noise in Raman spectra can obscure genuine peaks and complicate analysis. The Savitzky-Golay filter <span class="citation" data-cites="SavitzkyGolay1964">(<a href="#ref-SavitzkyGolay1964" role="doc-biblioref">Savitzky and Golay 1964</a>)</span> reduces noise while preserving peak shapes and positions through local polynomial regression, making it superior to simple moving averages for spectroscopic data.</p>
<p>For each point in the spectrum, the algorithm:</p>
<ol type="1">
<li>Considers a window of <code>window_length</code> points centered at that position</li>
<li>Fits a polynomial of degree <code>polyorder</code> to these points using least squares</li>
<li>Replaces the center point with the polynomial’s predicted value</li>
</ol>
<p>Mathematically, for a window centered at position <span class="math inline">\(i\)</span> with <span class="math inline">\(m = (\text{window\_length} - 1) / 2\)</span>:</p>
<p>The polynomial fit is:</p>
<p><span class="math display">\[
P(x) = a_0 + a_1 x + a_2 x^2 + \ldots + a_p x^p
\]</span></p>
<p>where <span class="math inline">\(p = \text{polyorder}\)</span>. The least squares objective minimizes:</p>
<p><span class="math display">\[
\sum_{j=i-m}^{i+m} [y_j - P(x_j)]^2
\]</span></p>
<p>The smoothed value is then <span class="math inline">\(y'_i = P(x_i)\)</span>.</p>
<p>The Savitzky-Golay filter can be efficiently implemented as a convolution with precomputed coefficients that depend only on <code>window_length</code> and <code>polyorder</code>, not on the data itself, giving it <span class="math inline">\(O(n)\)</span> complexity.</p>
<p><strong>Why it works:</strong> Averaging over the window reduces random noise by a factor of approximately <span class="math inline">\(\sqrt{\text{window\_length}}\)</span>, while polynomial fitting preserves local trends better than a simple moving average. This means narrow peaks are not significantly broadened, and the filter can even compute derivatives simultaneously, which is useful for peak finding algorithms.</p>
<p><strong>Parameter selection:</strong> The <code>window_length</code> must be odd and greater than <code>polyorder</code>. RamanSPy defaults to <code>window_length = 9</code> and <code>polyorder = 3</code> (cubic polynomial), which provides a good balance between noise reduction and peak preservation. Smaller windows (5-7) preserve narrow peaks better but provide less noise reduction, while larger windows (11-15) provide stronger noise reduction but may broaden narrow peaks.</p>
</section>
<section id="baseline-correction-aspls" class="level3">
<h3 class="anchored" data-anchor-id="baseline-correction-aspls">Baseline Correction (ASPLS)</h3>
<p>Baseline drift in Raman spectra arises from fluorescence, sample holder interference, or optical effects. This slowly-varying background can obscure peaks and complicate quantitative analysis. The ASPLS (Adaptive Smoothness Penalized Least Squares) method <span class="citation" data-cites="ZhangASPLS2010">(<a href="#ref-ZhangASPLS2010" role="doc-biblioref">Zhang, Chen, and Liang 2010</a>)</span> is an advanced variant of asymmetric least squares <span class="citation" data-cites="EilersALS2005">(<a href="#ref-EilersALS2005" role="doc-biblioref">Eilers and Boelens 2005</a>)</span> that adapts the smoothness constraint based on local signal characteristics.</p>
<p>The goal is to find a baseline <span class="math inline">\(z\)</span> that minimizes:</p>
<p><span class="math display">\[
Q = \sum_i w_i(y_i - z_i)^2 + \lambda \sum_j (\Delta^d z_j)^2
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(y_i\)</span> = observed spectrum values</li>
<li><span class="math inline">\(z_i\)</span> = baseline values</li>
<li><span class="math inline">\(w_i\)</span> = asymmetric weights</li>
<li><span class="math inline">\(\lambda\)</span> = smoothness penalty parameter</li>
<li><span class="math inline">\(\Delta^d\)</span> = <span class="math inline">\(d\)</span>-th order difference operator (typically <span class="math inline">\(d=2\)</span>)</li>
</ul>
<p>This formulation balances two competing objectives: <strong>fidelity</strong> (baseline close to data) and <strong>smoothness</strong> (baseline is smooth).</p>
<p><strong>Asymmetric weighting</strong> is the key innovation that prevents the baseline from following peaks. Unlike symmetric least squares, ASPLS uses:</p>
<p><span class="math display">\[
w_i =
\begin{cases}
p &amp; \text{if } y_i &gt; z_i \text{ (points above baseline)} \\
1-p &amp; \text{if } y_i \leq z_i \text{ (points below baseline)}
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(p \ll 0.5\)</span> (typically <span class="math inline">\(p = 0.01\)</span>). Since peaks are above the baseline, they receive low weight, while baseline regions receive high weight. This forces the fitted baseline to pass <strong>under</strong> the peaks.</p>
<p><strong>Smoothness penalty:</strong> The difference operator <span class="math inline">\(\Delta^d\)</span> penalizes roughness. For second-order differences (<span class="math inline">\(d=2\)</span>, the default):</p>
<p><span class="math display">\[
\Delta^2 z = [z_2 - 2z_1 + z_0, z_3 - 2z_2 + z_1, \ldots]
\]</span></p>
<p>This penalizes curvature changes (second derivative), encouraging a smooth baseline.</p>
<p><strong>Adaptive smoothness</strong> is the method’s key advantage: it varies <span class="math inline">\(\lambda\)</span> locally based on signal characteristics:</p>
<p><span class="math display">\[
\lambda_i^{\text{adaptive}} = \frac{\lambda}{1 + \alpha \times \text{feature}_i}
\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is an adaptation strength parameter and <span class="math inline">\(\text{feature}_i\)</span> represents local signal characteristics (e.g., magnitude of residual). This means:</p>
<ul>
<li><strong>Strong peaks</strong> (large residuals) → <span class="math inline">\(\lambda\)</span> decreases → more flexible baseline</li>
<li><strong>Flat regions</strong> → <span class="math inline">\(\lambda\)</span> remains high → smooth baseline</li>
</ul>
<p>This prevents the baseline from “chasing” strong peaks while maintaining smoothness in flat regions.</p>
<p>The algorithm iteratively solves the weighted penalized least squares problem, updating the asymmetric weights based on whether points are above or below the current baseline estimate, until convergence. RamanSPy defaults to <span class="math inline">\(\lambda = 10^5\)</span> and <code>diff_order = 2</code>, which work well for most Raman spectra.</p>
</section>
<section id="complete-preprocessing-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="complete-preprocessing-pipeline">Complete Preprocessing Pipeline</h3>
<p>The standard RamanSPy preprocessing workflow <span class="citation" data-cites="georgiev2024ramanspy">(<a href="#ref-georgiev2024ramanspy" role="doc-biblioref">Georgiev et al. 2024</a>)</span> applies these algorithms in a specific order, as the sequence of operations is critical for optimal results:</p>
<ol type="1">
<li><strong>Cropping</strong> - Focus on region of interest, reduce data size</li>
<li><strong>Whitaker-Hayes Despiking</strong> - Remove cosmic rays</li>
<li><strong>Savitzky-Golay Smoothing</strong> - Reduce noise</li>
<li><strong>ASPLS Baseline Correction</strong> - Remove baseline drift</li>
<li><strong>Normalization</strong> (optional) - Scale for comparison</li>
</ol>
<p>The default parameters recommended by RamanSPy provide a good starting point for most applications: cropping to 600-1800 <span class="math inline">\(cm^{-1}\)</span> (or full fingerprint region 400-1800 <span class="math inline">\(cm^{-1}\)</span>), despiking with <code>kernel_size=3</code> and <code>threshold=8.0</code>, smoothing with <code>window_length=9</code> and <code>polyorder=3</code>, and baseline correction with <span class="math inline">\(\lambda = 10^5\)</span> and <code>diff_order=2</code>. These parameters should be kept consistent across all spectra within a study to ensure reproducibility and comparability.</p>
</section>
</section>
</section>
<section id="sec-ml-raman" class="level1">
<h1>Machine Learning Approaches</h1>
<p>We now present a Machine Learning approach to predic the concentration of the different chemicals in the sample. The PLS Canonical algorithm is presented and explained in <a href="#sec-pls-canonical" class="quarto-xref">Section&nbsp;3.3</a>.</p>
<div class="quarto-embed-nb-cell">
<section id="raman-challenge-machine-learning-model-for-concentration-prediction" class="level2">
<h2 class="anchored" data-anchor-id="raman-challenge-machine-learning-model-for-concentration-prediction">Raman Challenge: Machine Learning Model for Concentration Prediction</h2>
<p>This notebook demonstrates the development of <strong>Partial Least Squares (PLS) regression models</strong> for predicting concentrations of three compounds from Raman spectra:</p>
<ul>
<li><strong>Glucose</strong> (C₆H₁₂O₆)</li>
<li><strong>Sodium acetate</strong> (Na_acetate)</li>
<li><strong>Magnesium sulfate</strong> (Mg_SO4)</li>
</ul>
<p>The analysis is performed <strong>one instrument at a time</strong> to account for instrument-specific variations in spectral characteristics. This approach ensures that models are tailored to the unique spectral response and calibration of each instrument, improving prediction accuracy and model reliability.</p>
<div id="fa60a041" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Literal</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ramanspy <span class="im">as</span> rp</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> GroupKFold, cross_val_predict</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cross_decomposition <span class="im">import</span> PLSRegression</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> r2_score, root_mean_squared_error</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span><span class="pp">SyntaxWarning</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="194df86f" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Data directory path</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>data_path <span class="op">=</span> Path(<span class="st">"../data/dig-4-bio-raman-transfer-learning-challenge"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Fingerprint region</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>MIN_WAVENUMBER <span class="op">=</span> <span class="dv">300</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>MAX_WAVENUMBER <span class="op">=</span> <span class="dv">1942</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard preprocessing pipeline without normalization</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>standard_pipeline_without_normalisation <span class="op">=</span> rp.preprocessing.Pipeline([</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.misc.Cropper(region<span class="op">=</span>(MIN_WAVENUMBER, MAX_WAVENUMBER)),  <span class="co"># Fingerprint region</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.despike.WhitakerHayes(),          <span class="co"># Remove cosmic rays</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.denoise.SavGol(window_length<span class="op">=</span><span class="dv">9</span>, polyorder<span class="op">=</span><span class="dv">3</span>),  <span class="co"># Smooth noise</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.baseline.ASPLS(),                 <span class="co"># Remove baseline drift</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rp.preprocessing.normalise.MinMax()  # Excluded for regression tasks</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard preprocessing pipeline with normalization</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>standard_pipeline <span class="op">=</span> rp.preprocessing.Pipeline([</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.misc.Cropper(region<span class="op">=</span>(MIN_WAVENUMBER, MAX_WAVENUMBER)),</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.despike.WhitakerHayes(),</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.denoise.SavGol(window_length<span class="op">=</span><span class="dv">9</span>, polyorder<span class="op">=</span><span class="dv">3</span>),</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.baseline.ASPLS(),</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    rp.preprocessing.normalise.MinMax()</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="0d6d3f6d" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">Utility functions</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_spectral_columns(df: pd.DataFrame) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">list</span>[<span class="bu">str</span>], <span class="bu">list</span>[<span class="bu">str</span>], np.ndarray]:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Identifies spectral data columns by checking if the column name can be converted to a float.</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">    This is a robust way to separate metadata from spectral data.</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    spectral_cols <span class="op">=</span> []</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    metadata_cols <span class="op">=</span> []</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">float</span>(col)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>            spectral_cols.append(col)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> (<span class="pp">ValueError</span>, <span class="pp">TypeError</span>):</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>            metadata_cols.append(col)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    wavenumbers <span class="op">=</span> pd.to_numeric(spectral_cols)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> metadata_cols, spectral_cols, wavenumbers</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="normalization-a-critical-preprocessing-decision" class="level3">
<h3 class="anchored" data-anchor-id="normalization-a-critical-preprocessing-decision">Normalization: A Critical Preprocessing Decision</h3>
<p>A fundamental preprocessing decision in quantitative Raman spectroscopy is whether to normalize the spectra. This choice involves an important trade-off:</p>
<ul>
<li><p><strong>Normalize</strong>: Ensures the model learns from <strong>chemical differences</strong> rather than measurement artifacts (laser power fluctuations, integration time variations, focusing differences, etc.). This helps remove instrumental effects that could confound the analysis.</p></li>
<li><p><strong>Don’t normalize</strong>: Preserves the <strong>relationship between peak height and concentration</strong>, which is essential for quantitative regression. Absolute intensity information can be directly related to analyte concentration in ideal conditions.</p></li>
</ul>
<p><strong>Objective</strong>: Display some random spectra from the dataset to visually assess the intensity variations and determine whether normalization is necessary for this analysis.</p>
<div id="13d916ef" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">Display some random spectra from the dataset</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data from anton_532 instrument</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(data_path <span class="op">/</span> <span class="st">"anton_532.csv"</span>).drop(columns<span class="op">=</span>[<span class="st">"MSM_present"</span>, <span class="st">"fold_idx"</span>])</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate spectral columns (numeric column names = wavenumbers) from metadata</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>metadata_cols, spectral_cols, wavenumbers <span class="op">=</span> find_spectral_columns(df)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>spectral_container <span class="op">=</span> rp.SpectralContainer(</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    spectral_data<span class="op">=</span>df[spectral_cols].values,</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    spectral_axis<span class="op">=</span>wavenumbers</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>spectral_container <span class="op">=</span> standard_pipeline_without_normalisation.<span class="bu">apply</span>(spectral_container)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Select 2 random spectra</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>random_indices <span class="op">=</span> np.random.choice(<span class="bu">len</span>(df), size<span class="op">=</span><span class="dv">2</span>, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> random_indices:</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    spectrum <span class="op">=</span> spectral_container[i]</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    metadata <span class="op">=</span> df[metadata_cols].iloc[i].to_dict()</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create informative title with concentration information</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    title <span class="op">=</span> (</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"Spectrum (preprocessed without normalization) - "</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"glucose </span><span class="sc">{</span>metadata[<span class="st">'glucose'</span>]<span class="sc">:.4f}</span><span class="ss"> g/L - "</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"Na_acetate </span><span class="sc">{</span>metadata[<span class="st">'Na_acetate'</span>]<span class="sc">:.4f}</span><span class="ss"> g/L - "</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"Mg_SO4 </span><span class="sc">{</span>metadata[<span class="st">'Mg_SO4'</span>]<span class="sc">:.4f}</span><span class="ss"> g/L"</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the spectrum</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    rp.plot.spectra(spectra<span class="op">=</span>[spectrum], plot_type<span class="op">=</span><span class="st">"single"</span>, title<span class="op">=</span>title)</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    rp.plot.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-5-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="discussion-normalization-in-the-preprocessing-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="discussion-normalization-in-the-preprocessing-pipeline">Discussion: Normalization in the Preprocessing Pipeline</h3>
<p>We observe that without normalization, spectral intensities can reach very high values (e.g., ~350 arbitrary units), which is problematic for machine learning models that expect scaled data. However, choosing the appropriate normalization method is challenging due to noise and subtle spectral variations that must be preserved for quantitative analysis.</p>
<p>Variations in overall spectral intensity can result from several instrumental factors:</p>
<ul>
<li><strong>Laser power fluctuations</strong>: Changes in laser output power between measurements</li>
<li><strong>Focusing/sampling position</strong>: Variations in sample positioning and laser focus</li>
<li><strong>Integration time</strong>: Differences in measurement duration</li>
<li><strong>Detector response</strong>: Variations in detector sensitivity or calibration</li>
</ul>
<p>Normalization corrects for these instrumental effects, ensuring that differences between spectra reflect <strong>chemical composition</strong> rather than <strong>measurement artifacts</strong>.</p>
<section id="common-normalization-methods" class="level4">
<h4 class="anchored" data-anchor-id="common-normalization-methods">Common Normalization Methods</h4>
<p><strong>1. Area Under the Curve (AUC) Scaling</strong></p>
<ul>
<li><strong>What it does:</strong> Divides each spectrum by its total area, making all spectra have area = 1.</li>
<li><strong>Why it’s problematic for regression:</strong> Destroys concentration information. Stronger peaks (indicating higher concentration) lead to a larger total area, but AUC scaling erases this difference by forcing all spectra to have the same area.</li>
<li><strong>Best for:</strong> Classification tasks (focus on spectral shape, not absolute intensity). <strong>Avoid for regression.</strong></li>
</ul>
<p><strong>2. MinMax Scaling</strong></p>
<ul>
<li><strong>What it does:</strong> Scales each spectrum so its minimum is 0 and maximum is 1.</li>
<li><strong>Problems for regression:</strong>
<ul>
<li>Scaling depends on the highest point, which may be a compound peak, solvent peak, or noise artifact.</li>
<li>Inconsistent scaling between samples distorts the linear relationship between peak height and concentration.</li>
<li>Different samples may have different scaling factors, making quantitative comparisons difficult.</li>
</ul></li>
<li><strong>Best for:</strong> Some ML classification tasks. <strong>Use with caution for regression.</strong></li>
</ul>
<p><strong>3. Internal Standard Normalization (Preferred for Quantitative Analysis)</strong></p>
<ul>
<li><p><strong>What it is:</strong> Normalize by dividing the analyte peak(s) by a stable reference peak (from a constant component or added internal standard).</p></li>
<li><p><strong>Why it’s best:</strong> Corrects for experimental variations (laser power, integration time, focus, detector response) while preserving the linear relationship needed for regression.</p></li>
<li><p><strong>Formula:</strong></p>
<pre><code>Normalized Signal = (Analyte Peak Intensity) / (Standard Peak Intensity)</code></pre></li>
<li><p><strong>Best for:</strong> Quantitative analysis and regression.</p></li>
</ul>
</section>
<section id="summary-table" class="level4">
<h4 class="anchored" data-anchor-id="summary-table">Summary Table</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 17%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>What it Does</th>
<th>Pro</th>
<th>Con</th>
<th>Best for</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>AUC Scaling</strong></td>
<td>Area = 1 for all spectra</td>
<td>Focuses on shape</td>
<td><strong>Destroys intensity info</strong></td>
<td>Classification</td>
</tr>
<tr class="even">
<td><strong>MinMax Scaling</strong></td>
<td>Scales to [0, 1]</td>
<td>Preserves relative peak heights</td>
<td>Inconsistent; distorts quantitative info</td>
<td>Some classification</td>
</tr>
<tr class="odd">
<td><strong>Internal Standard</strong></td>
<td>Ratio to stable peak</td>
<td><strong>Corrects for variations; preserves linearity</strong></td>
<td>Requires suitable standard/peak</td>
<td><strong>Regression, quantitative</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="decision" class="level4">
<h4 class="anchored" data-anchor-id="decision">Decision</h4>
<p>Unfortunately, internal standard normalization is difficult to implement in this context due to the lack of a suitable reference peak or internal standard in the dataset. Since we need to normalize the spectra due to very high intensity values that would otherwise cause numerical issues in the models, we choose to apply <strong>MinMax scaling</strong> while being aware of its limitations for quantitative regression tasks. This represents a pragmatic compromise between correcting for instrumental variations and preserving as much quantitative information as possible.</p>
</section>
</section>
<section id="machine-learning-approach" class="level3">
<h3 class="anchored" data-anchor-id="machine-learning-approach">Machine Learning Approach</h3>
<p>We now train PLS regression models for concentration prediction, analyzing each instrument separately to account for instrument-specific spectral characteristics.</p>
<section id="quantitative-modeling" class="level4">
<h4 class="anchored" data-anchor-id="quantitative-modeling">1. Quantitative Modeling</h4>
<p><strong>Model Choice:</strong></p>
<ul>
<li><strong>Partial Least Squares (PLS) Regression</strong> is the industry standard for spectroscopic data analysis. It effectively handles:
<ul>
<li><strong>High dimensionality</strong>: Many wavenumbers (features) relative to the number of samples</li>
<li><strong>Severe multicollinearity</strong>: Highly correlated spectral features (adjacent wavenumbers are typically very similar)</li>
<li><strong>Noise reduction</strong>: Projects data onto a lower-dimensional space of latent variables</li>
</ul></li>
<li>PLS finds latent variables (components) that <strong>maximize covariance</strong> between spectra (X) and concentrations (Y), making it ideal for quantitative prediction tasks.</li>
</ul>
<p><strong>Validation Strategy:</strong></p>
<ul>
<li>Use <strong>GroupKFold cross-validation</strong> with the sample <code>fold_idx</code> ID as the grouping variable.</li>
<li>This ensures that spectra from the same sample are <strong>not split across training and validation sets</strong>, providing a more realistic performance estimate that accounts for sample-to-sample variation.</li>
<li>This approach prevents data leakage and gives a better estimate of how the model will perform on truly unseen samples.</li>
</ul>
<p><strong>Hyperparameter Tuning:</strong></p>
<ul>
<li>The key parameter for PLS is the <strong>number of latent variables (components)</strong>.</li>
<li>Train models with increasing numbers of components (1-20) and select the number that yields the lowest <strong>Root Mean Squared Error of Cross-Validation (RMSECV)</strong>.</li>
<li>Too few components may underfit the data, while too many may overfit to noise.</li>
</ul>
</section>
<section id="model-evaluation-interpretation" class="level4">
<h4 class="anchored" data-anchor-id="model-evaluation-interpretation">2. Model Evaluation &amp; Interpretation</h4>
<p><strong>Performance Metrics:</strong></p>
<ul>
<li>Evaluate the final model using the optimal number of components.</li>
<li>Calculate <strong>R²</strong> (coefficient of determination) and <strong>RMSE</strong> (Root Mean Squared Error) from cross-validated predictions.</li>
<li>R² indicates the proportion of variance explained by the model (closer to 1 is better).</li>
<li>RMSE indicates the average prediction error in concentration units (g/L).</li>
</ul>
<p><strong>Visualization:</strong></p>
<ul>
<li>Generate <strong>Predicted vs.&nbsp;Actual</strong> plots to provide a clear visual assessment of model performance.</li>
<li>Inspect <strong>PLS loadings</strong> to identify which spectral regions (wavenumbers) the model uses for predictions, enabling chemical interpretation and validation of the model’s behavior.</li>
</ul>
<div id="e7d2832a" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Loading the data</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>instrument: Literal[<span class="st">"anton_532"</span>, <span class="st">"anton_785"</span>, <span class="st">"kaiser"</span>, <span class="st">"metrohm"</span>, <span class="st">"mettler_toledo"</span>, <span class="st">"tec5"</span>, <span class="st">"timegate"</span>, <span class="st">"tornado"</span>] <span class="op">=</span> <span class="st">"anton_532"</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(data_path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>instrument<span class="sc">}</span><span class="ss">.csv"</span>).drop(columns<span class="op">=</span>[<span class="st">"MSM_present"</span>])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">200.0</th>
<th data-quarto-table-cell-role="th">202.0</th>
<th data-quarto-table-cell-role="th">204.0</th>
<th data-quarto-table-cell-role="th">206.0</th>
<th data-quarto-table-cell-role="th">208.0</th>
<th data-quarto-table-cell-role="th">210.0</th>
<th data-quarto-table-cell-role="th">212.0</th>
<th data-quarto-table-cell-role="th">214.0</th>
<th data-quarto-table-cell-role="th">216.0</th>
<th data-quarto-table-cell-role="th">218.0</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">3490.0</th>
<th data-quarto-table-cell-role="th">3492.0</th>
<th data-quarto-table-cell-role="th">3494.0</th>
<th data-quarto-table-cell-role="th">3496.0</th>
<th data-quarto-table-cell-role="th">3498.0</th>
<th data-quarto-table-cell-role="th">3500.0</th>
<th data-quarto-table-cell-role="th">glucose</th>
<th data-quarto-table-cell-role="th">Na_acetate</th>
<th data-quarto-table-cell-role="th">Mg_SO4</th>
<th data-quarto-table-cell-role="th">fold_idx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>7519.06</td>
<td>7582.15</td>
<td>7379.73</td>
<td>7054.04</td>
<td>6818.64</td>
<td>6684.24</td>
<td>6562.20</td>
<td>6398.03</td>
<td>6256.17</td>
<td>6135.72</td>
<td>...</td>
<td>6475.20</td>
<td>6573.45</td>
<td>6488.44</td>
<td>6284.99</td>
<td>6216.51</td>
<td>6409.21</td>
<td>0.26335</td>
<td>1.43570</td>
<td>1.44101</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>7414.24</td>
<td>7502.98</td>
<td>7327.93</td>
<td>7002.97</td>
<td>6760.01</td>
<td>6638.17</td>
<td>6539.84</td>
<td>6360.47</td>
<td>6200.67</td>
<td>6080.42</td>
<td>...</td>
<td>6451.34</td>
<td>6564.97</td>
<td>6465.79</td>
<td>6241.37</td>
<td>6171.89</td>
<td>6358.46</td>
<td>0.26335</td>
<td>1.43570</td>
<td>1.44101</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>7376.45</td>
<td>7474.90</td>
<td>7304.00</td>
<td>6961.46</td>
<td>6691.31</td>
<td>6557.30</td>
<td>6470.64</td>
<td>6309.66</td>
<td>6177.40</td>
<td>6090.05</td>
<td>...</td>
<td>6432.22</td>
<td>6521.16</td>
<td>6452.89</td>
<td>6248.68</td>
<td>6137.06</td>
<td>6318.74</td>
<td>0.26335</td>
<td>1.43570</td>
<td>1.44101</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>7383.60</td>
<td>7456.90</td>
<td>7264.59</td>
<td>6938.71</td>
<td>6707.66</td>
<td>6594.61</td>
<td>6493.20</td>
<td>6307.50</td>
<td>6144.74</td>
<td>6033.89</td>
<td>...</td>
<td>6412.12</td>
<td>6532.58</td>
<td>6459.36</td>
<td>6240.35</td>
<td>6146.15</td>
<td>6325.52</td>
<td>0.26335</td>
<td>1.43570</td>
<td>1.44101</td>
<td>0</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>7345.77</td>
<td>7435.40</td>
<td>7263.58</td>
<td>6929.82</td>
<td>6671.51</td>
<td>6544.19</td>
<td>6459.28</td>
<td>6302.71</td>
<td>6158.40</td>
<td>6043.02</td>
<td>...</td>
<td>6414.26</td>
<td>6530.51</td>
<td>6435.62</td>
<td>6214.08</td>
<td>6156.26</td>
<td>6348.95</td>
<td>0.26335</td>
<td>1.43570</td>
<td>1.44101</td>
<td>0</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">265</th>
<td>7832.00</td>
<td>7938.65</td>
<td>7758.85</td>
<td>7401.53</td>
<td>7122.56</td>
<td>6982.76</td>
<td>6884.94</td>
<td>6702.59</td>
<td>6537.42</td>
<td>6417.34</td>
<td>...</td>
<td>7790.07</td>
<td>7890.47</td>
<td>7786.45</td>
<td>7544.57</td>
<td>7448.89</td>
<td>7652.59</td>
<td>10.71080</td>
<td>0.74408</td>
<td>3.48079</td>
<td>4</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">266</th>
<td>7799.25</td>
<td>7874.64</td>
<td>7683.97</td>
<td>7335.51</td>
<td>7069.06</td>
<td>6933.33</td>
<td>6827.90</td>
<td>6633.28</td>
<td>6466.11</td>
<td>6358.28</td>
<td>...</td>
<td>7735.00</td>
<td>7846.83</td>
<td>7756.49</td>
<td>7530.37</td>
<td>7427.52</td>
<td>7587.48</td>
<td>10.71080</td>
<td>0.74408</td>
<td>3.48079</td>
<td>4</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">267</th>
<td>7752.49</td>
<td>7823.53</td>
<td>7631.56</td>
<td>7311.92</td>
<td>7087.74</td>
<td>6973.90</td>
<td>6867.04</td>
<td>6686.11</td>
<td>6522.25</td>
<td>6391.02</td>
<td>...</td>
<td>7713.69</td>
<td>7774.98</td>
<td>7694.02</td>
<td>7490.46</td>
<td>7377.11</td>
<td>7541.42</td>
<td>10.71080</td>
<td>0.74408</td>
<td>3.48079</td>
<td>4</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">268</th>
<td>7757.55</td>
<td>7803.91</td>
<td>7606.17</td>
<td>7295.83</td>
<td>7082.62</td>
<td>6976.21</td>
<td>6870.14</td>
<td>6678.14</td>
<td>6495.80</td>
<td>6352.90</td>
<td>...</td>
<td>7702.41</td>
<td>7801.14</td>
<td>7693.90</td>
<td>7459.89</td>
<td>7372.70</td>
<td>7559.06</td>
<td>10.71080</td>
<td>0.74408</td>
<td>3.48079</td>
<td>4</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">269</th>
<td>7726.52</td>
<td>7799.61</td>
<td>7607.11</td>
<td>7281.07</td>
<td>7047.06</td>
<td>6924.05</td>
<td>6810.98</td>
<td>6627.21</td>
<td>6470.48</td>
<td>6357.52</td>
<td>...</td>
<td>7624.59</td>
<td>7756.07</td>
<td>7675.02</td>
<td>7459.47</td>
<td>7398.34</td>
<td>7572.52</td>
<td>10.71080</td>
<td>0.74408</td>
<td>3.48079</td>
<td>4</td>
</tr>
</tbody>
</table>

<p>270 rows × 1655 columns</p>
</div>
</div>
</div>
<div id="fef212f0" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Processing the data</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>metadata_cols, spectral_cols, wavenumbers <span class="op">=</span> find_spectral_columns(df)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> df[<span class="st">"fold_idx"</span>].to_numpy()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>spectra_raw_df <span class="op">=</span> df[spectral_cols]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> df[[<span class="st">"glucose"</span>, <span class="st">"Na_acetate"</span>, <span class="st">"Mg_SO4"</span>]].to_numpy()</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>spectral_container <span class="op">=</span> rp.SpectralContainer(</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    spectral_data<span class="op">=</span>spectra_raw_df.values,</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    spectral_axis<span class="op">=</span>wavenumbers,</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>processed_spectra <span class="op">=</span> standard_pipeline.<span class="bu">apply</span>(spectral_container)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>X_processed <span class="op">=</span> processed_spectra.spectral_data</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="d1e116fe" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We will test a range of components (latent variables)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>n_components_range <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">21</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>rmsecv_scores <span class="op">=</span> []</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>r2cv_scores <span class="op">=</span> []</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Use GroupKFold to ensure spectra from the same sample are not split across folds</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co"># This gives a more realistic performance estimate. We use fold_idx as the group.</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>cv_splitter <span class="op">=</span> GroupKFold(n_splits<span class="op">=</span><span class="dv">5</span>) <span class="co"># 5 groups for 5 folds</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n_comp <span class="kw">in</span> n_components_range:</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    pls <span class="op">=</span> PLSRegression(n_components<span class="op">=</span>n_comp)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Predict using cross-validation</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    y_pred_cv <span class="op">=</span> cross_val_predict(pls, X_processed, Y, cv<span class="op">=</span>cv_splitter, groups<span class="op">=</span>groups)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    rmsecv <span class="op">=</span> root_mean_squared_error(Y, y_pred_cv)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    r2cv <span class="op">=</span> r2_score(Y, y_pred_cv)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    rmsecv_scores.append(rmsecv)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    r2cv_scores.append(r2cv)</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"RMSECV with </span><span class="sc">{</span>n_comp<span class="sc">}</span><span class="ss"> components: </span><span class="sc">{</span>rmsecv<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"R2CV with </span><span class="sc">{</span>n_comp<span class="sc">}</span><span class="ss"> components: </span><span class="sc">{</span>r2cv<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the optimal number of components (the one with the minimum RMSECV)</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>optimal_n_components <span class="op">=</span> n_components_range[np.argmin(rmsecv_scores)]</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal number of PLS components found: </span><span class="sc">{</span>optimal_n_components<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Plot RMSECV vs. Number of Components, and R2 vs. Number of Components ---</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>color_rmse <span class="op">=</span> <span class="st">'tab:red'</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>color_r2 <span class="op">=</span> <span class="st">'tab:blue'</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Number of Components'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'RMSE of Cross-Validation (g/L)'</span>, color<span class="op">=</span>color_rmse, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>ax1.plot(n_components_range, rmsecv_scores, <span class="st">'o-'</span>, mfc<span class="op">=</span><span class="st">'w'</span>, color<span class="op">=</span>color_rmse, label<span class="op">=</span><span class="st">'RMSECV'</span>)</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>ax1.axvline(x<span class="op">=</span>optimal_n_components, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Optimal Components = </span><span class="sc">{</span>optimal_n_components<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>ax1.tick_params(axis<span class="op">=</span><span class="st">'y'</span>, labelcolor<span class="op">=</span>color_rmse)</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>ax1.legend(loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> ax1.twinx()</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'R² of Cross-Validation'</span>, color<span class="op">=</span>color_r2, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>ax2.plot(n_components_range, r2cv_scores, <span class="st">'-'</span>, color<span class="op">=</span>color_r2, label<span class="op">=</span><span class="st">'R²'</span>)</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>ax2.tick_params(axis<span class="op">=</span><span class="st">'y'</span>, labelcolor<span class="op">=</span>color_r2)</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>ax2.legend(loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'RMSECV and R² vs. Number of PLS Components'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>RMSECV with 1 components: 2.0614
R2CV with 1 components: 0.0021
RMSECV with 2 components: 1.9507
R2CV with 2 components: 0.1411
RMSECV with 3 components: 2.0019
R2CV with 3 components: 0.1405
RMSECV with 4 components: 1.8235
R2CV with 4 components: 0.2169
RMSECV with 5 components: 1.6823
R2CV with 5 components: 0.3021
RMSECV with 6 components: 1.6804
R2CV with 6 components: 0.2938
RMSECV with 7 components: 1.5609
R2CV with 7 components: 0.3664
RMSECV with 8 components: 1.5313
R2CV with 8 components: 0.3533
RMSECV with 9 components: 1.5394
R2CV with 9 components: 0.3469
RMSECV with 10 components: 1.5132
R2CV with 10 components: 0.3592
RMSECV with 11 components: 1.5052
R2CV with 11 components: 0.3569
RMSECV with 12 components: 1.5003
R2CV with 12 components: 0.3398
RMSECV with 13 components: 1.5246
R2CV with 13 components: 0.3177
RMSECV with 14 components: 1.5137
R2CV with 14 components: 0.3010
RMSECV with 15 components: 1.5298
R2CV with 15 components: 0.2747
RMSECV with 16 components: 1.5465
R2CV with 16 components: 0.2485
RMSECV with 17 components: 1.5418
R2CV with 17 components: 0.2396
RMSECV with 18 components: 1.5498
R2CV with 18 components: 0.2290
RMSECV with 19 components: 1.5826
R2CV with 19 components: 0.1800
RMSECV with 20 components: 1.5891
R2CV with 20 components: 0.1416
Optimal number of PLS components found: 12</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-8-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="b5dd912a" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Final Model Training and Evaluation</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the final PLS model with the optimal number of components</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>final_pls_model <span class="op">=</span> PLSRegression(n_components<span class="op">=</span>optimal_n_components)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Get cross-validated predictions for the final model</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>y_pred_final <span class="op">=</span> cross_val_predict(final_pls_model, X_processed, Y, cv<span class="op">=</span>cv_splitter, groups<span class="op">=</span>groups)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate final performance metrics (overall)</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>final_rmse <span class="op">=</span> root_mean_squared_error(Y, y_pred_final)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>final_r2 <span class="op">=</span> r2_score(Y, y_pred_final)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Final Cross-Validated Model Performance (Overall):"</span>)</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"R²: </span><span class="sc">{</span>final_r2<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"RMSE: </span><span class="sc">{</span>final_rmse<span class="sc">:.4f}</span><span class="ss"> g/L"</span>)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate individual metrics for each target</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>target_names <span class="op">=</span> [<span class="st">"Glucose"</span>, <span class="st">"Na_acetate"</span>, <span class="st">"Mg_SO4"</span>]</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>target_metrics <span class="op">=</span> []</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, target_name <span class="kw">in</span> <span class="bu">enumerate</span>(target_names):</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    Y_target <span class="op">=</span> Y[:, i]</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    y_pred_target <span class="op">=</span> y_pred_final[:, i]</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    r2_target <span class="op">=</span> r2_score(Y_target, y_pred_target)</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    rmse_target <span class="op">=</span> root_mean_squared_error(Y_target, y_pred_target)</span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>    target_metrics.append((r2_target, rmse_target))</span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>target_name<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  R²: </span><span class="sc">{</span>r2_target<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  RMSE: </span><span class="sc">{</span>rmse_target<span class="sc">:.4f}</span><span class="ss"> g/L"</span>)</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Predicted vs. Actual Plots for All Targets ---</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">5</span>))</span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (target_name, ax) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(target_names, axes)):</span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>    Y_target <span class="op">=</span> Y[:, i]</span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>    y_pred_target <span class="op">=</span> y_pred_final[:, i]</span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>    r2_target, rmse_target <span class="op">=</span> target_metrics[i]</span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span>Y_target, y<span class="op">=</span>y_pred_target, alpha<span class="op">=</span><span class="fl">0.7</span>, ax<span class="op">=</span>ax)</span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a>    ax.plot([Y_target.<span class="bu">min</span>(), Y_target.<span class="bu">max</span>()], [Y_target.<span class="bu">min</span>(), Y_target.<span class="bu">max</span>()], </span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>            <span class="st">'r--'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'1:1 Line'</span>)</span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f'Predicted vs. Actual </span><span class="sc">{</span>target_name<span class="sc">}</span><span class="ss">'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Actual Concentration (g/L)'</span>, fontsize<span class="op">=</span><span class="dv">11</span>)</span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Predicted Concentration (g/L)'</span>, fontsize<span class="op">=</span><span class="dv">11</span>)</span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a>    ax.text(<span class="fl">0.05</span>, <span class="fl">0.95</span>, <span class="ss">f'R² = </span><span class="sc">{</span>r2_target<span class="sc">:.4f}</span><span class="ch">\n</span><span class="ss">RMSE = </span><span class="sc">{</span>rmse_target<span class="sc">:.4f}</span><span class="ss"> g/L'</span>, </span>
<span id="cb27-48"><a href="#cb27-48" aria-hidden="true" tabindex="-1"></a>            transform<span class="op">=</span>ax.transAxes, fontsize<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb27-49"><a href="#cb27-49" aria-hidden="true" tabindex="-1"></a>            bbox<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>), verticalalignment<span class="op">=</span><span class="st">'top'</span>)</span>
<span id="cb27-50"><a href="#cb27-50" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb27-51"><a href="#cb27-51" aria-hidden="true" tabindex="-1"></a>    ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb27-52"><a href="#cb27-52" aria-hidden="true" tabindex="-1"></a>    ax.set_aspect(<span class="st">'equal'</span>, adjustable<span class="op">=</span><span class="st">'box'</span>)</span>
<span id="cb27-53"><a href="#cb27-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-54"><a href="#cb27-54" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb27-55"><a href="#cb27-55" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Final Cross-Validated Model Performance (Overall):
R²: 0.3398
RMSE: 1.5003 g/L
Glucose:
  R²: 0.3915
  RMSE: 3.3367 g/L
Na_acetate:
  R²: -0.1697
  RMSE: 0.5485 g/L
Mg_SO4:
  R²: 0.7974
  RMSE: 0.6159 g/L</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-9-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="1ee961cd" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Model Interpretation - Inspecting PLS Loadings</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"># To interpret the model, we fit it on all data and inspect the loadings.</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"># The loadings show which variables (wavenumbers) are important for each component.</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>final_pls_model.fit(X_processed, Y)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>loadings <span class="op">=</span> final_pls_model.x_loadings_</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Plot Loadings for the first few components ---</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Ensure wavenumbers and loadings have matching dimensions</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>wavenumbers_plot <span class="op">=</span> wavenumbers</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">hasattr</span>(wavenumbers, <span class="st">'values'</span>):</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    wavenumbers_plot <span class="op">=</span> wavenumbers.values</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(wavenumbers_plot) <span class="op">!=</span> loadings.shape[<span class="dv">0</span>]:</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Try to slice wavenumbers to match loadings shape</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    wavenumbers_plot <span class="op">=</span> wavenumbers_plot[:loadings.shape[<span class="dv">0</span>]]</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">3</span>, optimal_n_components)): <span class="co"># Plot up to the first 3 components</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    plt.plot(wavenumbers_plot, loadings[:, i], label<span class="op">=</span><span class="ss">f'Component </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'PLS Loadings'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Raman Shift (cm⁻¹)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Loading Weight'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="50e94436" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate PLS Models Per Target</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Training one PLS model per target allows:</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"># - Better interpretability: each target has its own loadings showing which </span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co">#   spectral regions are important for that specific compound</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co"># - Independent optimization: each target can have its own optimal number of </span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">#   components</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co"># - Potentially better performance: models can focus on the specific spectral </span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co">#   regions relevant to each compound</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>target_names <span class="op">=</span> [<span class="st">"glucose"</span>, <span class="st">"Na_acetate"</span>, <span class="st">"Mg_SO4"</span>]</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>target_models <span class="op">=</span> {}</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>target_optimal_components <span class="op">=</span> {}</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>target_metrics_separate <span class="op">=</span> {}</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>target_predictions_separate <span class="op">=</span> {}</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Store single model metrics for comparison (from cell 11)</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>target_metrics_single <span class="op">=</span> {}</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, target_name <span class="kw">in</span> <span class="bu">enumerate</span>(target_names):</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    Y_target <span class="op">=</span> Y[:, i]</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    y_pred_target <span class="op">=</span> y_pred_final[:, i]</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    r2_target <span class="op">=</span> r2_score(Y_target, y_pred_target)</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    rmse_target <span class="op">=</span> root_mean_squared_error(Y_target, y_pred_target)</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>    target_metrics_single[target_name] <span class="op">=</span> (r2_target, rmse_target)</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Train separate PLS model for each target</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> target_idx, target_name <span class="kw">in</span> <span class="bu">enumerate</span>(target_names):</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Training PLS model for </span><span class="sc">{</span>target_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract single target</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    Y_target <span class="op">=</span> Y[:, target_idx].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)  <span class="co"># Reshape to (n_samples, 1)</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find optimal number of components for this target</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>    n_components_range <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">21</span>)</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    rmsecv_scores <span class="op">=</span> []</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>    r2cv_scores <span class="op">=</span> []</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n_comp <span class="kw">in</span> n_components_range:</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>        pls <span class="op">=</span> PLSRegression(n_components<span class="op">=</span>n_comp)</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>        y_pred_cv <span class="op">=</span> cross_val_predict(pls, X_processed, Y_target, cv<span class="op">=</span>cv_splitter, groups<span class="op">=</span>groups)</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>        rmsecv <span class="op">=</span> root_mean_squared_error(Y_target, y_pred_cv)</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>        r2cv <span class="op">=</span> r2_score(Y_target, y_pred_cv)</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>        rmsecv_scores.append(rmsecv)</span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>        r2cv_scores.append(r2cv)</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>n_comp<span class="sc">:2d}</span><span class="ss"> components: RMSECV=</span><span class="sc">{</span>rmsecv<span class="sc">:.4f}</span><span class="ss">, R²CV=</span><span class="sc">{</span>r2cv<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find optimal number of components</span></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>    optimal_n_components <span class="op">=</span> n_components_range[np.argmin(rmsecv_scores)]</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>    target_optimal_components[target_name] <span class="op">=</span> optimal_n_components</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">  Optimal components for </span><span class="sc">{</span>target_name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>optimal_n_components<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Train final model and get cross-validated predictions</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>    final_pls <span class="op">=</span> PLSRegression(n_components<span class="op">=</span>optimal_n_components)</span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>    y_pred_final_separate <span class="op">=</span> cross_val_predict(final_pls, X_processed, Y_target, cv<span class="op">=</span>cv_splitter, groups<span class="op">=</span>groups)</span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate metrics</span></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>    r2_final <span class="op">=</span> r2_score(Y_target, y_pred_final_separate)</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>    rmse_final <span class="op">=</span> root_mean_squared_error(Y_target, y_pred_final_separate)</span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>    target_metrics_separate[target_name] <span class="op">=</span> (r2_final, rmse_final)</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a>    target_models[target_name] <span class="op">=</span> final_pls</span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a>    target_predictions_separate[target_name] <span class="op">=</span> y_pred_final_separate</span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Final R²: </span><span class="sc">{</span>r2_final<span class="sc">:.4f}</span><span class="ss">, RMSE: </span><span class="sc">{</span>rmse_final<span class="sc">:.4f}</span><span class="ss"> g/L"</span>)</span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Loadings for Each Target (Much More Interpretable!)</span></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="bu">len</span>(target_names), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">5</span><span class="op">*</span><span class="bu">len</span>(target_names)))</span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Handle case where we have only one target (axes would be 1D, not 2D)</span></span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(target_names) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> [axes]</span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-79"><a href="#cb30-79" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, target_name <span class="kw">in</span> <span class="bu">enumerate</span>(target_names):</span>
<span id="cb30-80"><a href="#cb30-80" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> target_models[target_name]</span>
<span id="cb30-81"><a href="#cb30-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fit the model on all data to get loadings</span></span>
<span id="cb30-82"><a href="#cb30-82" aria-hidden="true" tabindex="-1"></a>    model.fit(X_processed, Y[:, idx].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb30-83"><a href="#cb30-83" aria-hidden="true" tabindex="-1"></a>    loadings <span class="op">=</span> model.x_loadings_</span>
<span id="cb30-84"><a href="#cb30-84" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-85"><a href="#cb30-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use wavenumbers from processed spectra to match loadings dimensions</span></span>
<span id="cb30-86"><a href="#cb30-86" aria-hidden="true" tabindex="-1"></a>    wavenumbers_processed <span class="op">=</span> processed_spectra.spectral_axis</span>
<span id="cb30-87"><a href="#cb30-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">hasattr</span>(wavenumbers_processed, <span class="st">'values'</span>):</span>
<span id="cb30-88"><a href="#cb30-88" aria-hidden="true" tabindex="-1"></a>        wavenumbers_processed <span class="op">=</span> wavenumbers_processed.values</span>
<span id="cb30-89"><a href="#cb30-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-90"><a href="#cb30-90" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> axes[idx]</span>
<span id="cb30-91"><a href="#cb30-91" aria-hidden="true" tabindex="-1"></a>    n_comp_to_plot <span class="op">=</span> <span class="bu">min</span>(<span class="dv">3</span>, target_optimal_components[target_name])</span>
<span id="cb30-92"><a href="#cb30-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> comp_idx <span class="kw">in</span> <span class="bu">range</span>(n_comp_to_plot):</span>
<span id="cb30-93"><a href="#cb30-93" aria-hidden="true" tabindex="-1"></a>        ax.plot(wavenumbers_processed, loadings[:, comp_idx], </span>
<span id="cb30-94"><a href="#cb30-94" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="ss">f'Component </span><span class="sc">{</span>comp_idx<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb30-95"><a href="#cb30-95" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-96"><a href="#cb30-96" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f'PLS Loadings for </span><span class="sc">{</span>target_name<span class="sc">}</span><span class="ss"> (Optimal: </span><span class="sc">{</span>target_optimal_components[target_name]<span class="sc">}</span><span class="ss"> components)'</span>, </span>
<span id="cb30-97"><a href="#cb30-97" aria-hidden="true" tabindex="-1"></a>                 fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb30-98"><a href="#cb30-98" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Raman Shift (cm⁻¹)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb30-99"><a href="#cb30-99" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Loading Weight'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb30-100"><a href="#cb30-100" aria-hidden="true" tabindex="-1"></a>    ax.legend(loc<span class="op">=</span><span class="st">'best'</span>)</span>
<span id="cb30-101"><a href="#cb30-101" aria-hidden="true" tabindex="-1"></a>    ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb30-102"><a href="#cb30-102" aria-hidden="true" tabindex="-1"></a>    ax.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb30-103"><a href="#cb30-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-104"><a href="#cb30-104" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb30-105"><a href="#cb30-105" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb30-106"><a href="#cb30-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-107"><a href="#cb30-107" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-108"><a href="#cb30-108" aria-hidden="true" tabindex="-1"></a><span class="co"># Performance Comparison: Single vs. Separate Models</span></span>
<span id="cb30-109"><a href="#cb30-109" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-110"><a href="#cb30-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-111"><a href="#cb30-111" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb30-112"><a href="#cb30-112" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Performance Comparison: Single Multi-Output Model vs. Separate Models"</span>)</span>
<span id="cb30-113"><a href="#cb30-113" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb30-114"><a href="#cb30-114" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Target'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Single Model R²'</span><span class="sc">:&lt;18}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Separate Model R²'</span><span class="sc">:&lt;18}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'R² Improvement'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Single RMSE'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Separate RMSE'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'RMSE Improvement'</span><span class="sc">:&lt;15}</span><span class="ss">"</span>)</span>
<span id="cb30-115"><a href="#cb30-115" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb30-116"><a href="#cb30-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-117"><a href="#cb30-117" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> target_name <span class="kw">in</span> target_names:</span>
<span id="cb30-118"><a href="#cb30-118" aria-hidden="true" tabindex="-1"></a>    single_r2, single_rmse <span class="op">=</span> target_metrics_single[target_name]</span>
<span id="cb30-119"><a href="#cb30-119" aria-hidden="true" tabindex="-1"></a>    separate_r2, separate_rmse <span class="op">=</span> target_metrics_separate[target_name]</span>
<span id="cb30-120"><a href="#cb30-120" aria-hidden="true" tabindex="-1"></a>    r2_improvement <span class="op">=</span> separate_r2 <span class="op">-</span> single_r2</span>
<span id="cb30-121"><a href="#cb30-121" aria-hidden="true" tabindex="-1"></a>    rmse_improvement <span class="op">=</span> single_rmse <span class="op">-</span> separate_rmse  <span class="co"># Positive = better (lower RMSE)</span></span>
<span id="cb30-122"><a href="#cb30-122" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-123"><a href="#cb30-123" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>target_name<span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span>single_r2<span class="sc">:&gt;17.4f}</span><span class="ss"> </span><span class="sc">{</span>separate_r2<span class="sc">:&gt;17.4f}</span><span class="ss"> </span><span class="sc">{</span>r2_improvement<span class="sc">:&gt;+14.4f}</span><span class="ss"> </span><span class="sc">{</span>single_rmse<span class="sc">:&gt;14.4f}</span><span class="ss"> g/L </span><span class="sc">{</span>separate_rmse<span class="sc">:&gt;14.4f}</span><span class="ss"> g/L </span><span class="sc">{</span>rmse_improvement<span class="sc">:&gt;+14.4f}</span><span class="ss"> g/L"</span>)</span>
<span id="cb30-124"><a href="#cb30-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-125"><a href="#cb30-125" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb30-126"><a href="#cb30-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-127"><a href="#cb30-127" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-128"><a href="#cb30-128" aria-hidden="true" tabindex="-1"></a><span class="co"># Predicted vs. Actual Plots for Separate Models</span></span>
<span id="cb30-129"><a href="#cb30-129" aria-hidden="true" tabindex="-1"></a><span class="co"># =============================================================================</span></span>
<span id="cb30-130"><a href="#cb30-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-131"><a href="#cb30-131" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">5</span>))</span>
<span id="cb30-132"><a href="#cb30-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-133"><a href="#cb30-133" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, (target_name, ax) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(target_names, axes)):</span>
<span id="cb30-134"><a href="#cb30-134" aria-hidden="true" tabindex="-1"></a>    Y_target <span class="op">=</span> Y[:, idx]</span>
<span id="cb30-135"><a href="#cb30-135" aria-hidden="true" tabindex="-1"></a>    y_pred_target <span class="op">=</span> target_predictions_separate[target_name].flatten()</span>
<span id="cb30-136"><a href="#cb30-136" aria-hidden="true" tabindex="-1"></a>    r2_target, rmse_target <span class="op">=</span> target_metrics_separate[target_name]</span>
<span id="cb30-137"><a href="#cb30-137" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-138"><a href="#cb30-138" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span>Y_target, y<span class="op">=</span>y_pred_target, alpha<span class="op">=</span><span class="fl">0.7</span>, ax<span class="op">=</span>ax)</span>
<span id="cb30-139"><a href="#cb30-139" aria-hidden="true" tabindex="-1"></a>    ax.plot([Y_target.<span class="bu">min</span>(), Y_target.<span class="bu">max</span>()], [Y_target.<span class="bu">min</span>(), Y_target.<span class="bu">max</span>()], </span>
<span id="cb30-140"><a href="#cb30-140" aria-hidden="true" tabindex="-1"></a>            <span class="st">'r--'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'1:1 Line'</span>)</span>
<span id="cb30-141"><a href="#cb30-141" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f'Predicted vs. Actual </span><span class="sc">{</span>target_name<span class="sc">}</span><span class="ss"> (Separate Model)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb30-142"><a href="#cb30-142" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Actual Concentration (g/L)'</span>, fontsize<span class="op">=</span><span class="dv">11</span>)</span>
<span id="cb30-143"><a href="#cb30-143" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Predicted Concentration (g/L)'</span>, fontsize<span class="op">=</span><span class="dv">11</span>)</span>
<span id="cb30-144"><a href="#cb30-144" aria-hidden="true" tabindex="-1"></a>    ax.text(<span class="fl">0.05</span>, <span class="fl">0.95</span>, <span class="ss">f'R² = </span><span class="sc">{</span>r2_target<span class="sc">:.4f}</span><span class="ch">\n</span><span class="ss">RMSE = </span><span class="sc">{</span>rmse_target<span class="sc">:.4f}</span><span class="ss"> g/L</span><span class="ch">\n</span><span class="ss">Components = </span><span class="sc">{</span>target_optimal_components[target_name]<span class="sc">}</span><span class="ss">'</span>, </span>
<span id="cb30-145"><a href="#cb30-145" aria-hidden="true" tabindex="-1"></a>            transform<span class="op">=</span>ax.transAxes, fontsize<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb30-146"><a href="#cb30-146" aria-hidden="true" tabindex="-1"></a>            bbox<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>), verticalalignment<span class="op">=</span><span class="st">'top'</span>)</span>
<span id="cb30-147"><a href="#cb30-147" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb30-148"><a href="#cb30-148" aria-hidden="true" tabindex="-1"></a>    ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb30-149"><a href="#cb30-149" aria-hidden="true" tabindex="-1"></a>    ax.set_aspect(<span class="st">'equal'</span>, adjustable<span class="op">=</span><span class="st">'box'</span>)</span>
<span id="cb30-150"><a href="#cb30-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-151"><a href="#cb30-151" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb30-152"><a href="#cb30-152" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
============================================================
Training PLS model for glucose
============================================================
   1 components: RMSECV=4.3714, R²CV=-0.0445
   2 components: RMSECV=4.6011, R²CV=-0.1571
   3 components: RMSECV=3.8873, R²CV=0.1740
   4 components: RMSECV=3.6280, R²CV=0.2806
   5 components: RMSECV=3.3775, R²CV=0.3765
   6 components: RMSECV=3.3941, R²CV=0.3703
   7 components: RMSECV=3.3577, R²CV=0.3838
   8 components: RMSECV=3.3525, R²CV=0.3857
   9 components: RMSECV=3.4223, R²CV=0.3598
  10 components: RMSECV=3.4784, R²CV=0.3387
  11 components: RMSECV=3.5761, R²CV=0.3010
  12 components: RMSECV=3.6763, R²CV=0.2613
  13 components: RMSECV=3.7758, R²CV=0.2207
  14 components: RMSECV=3.8433, R²CV=0.1926
  15 components: RMSECV=3.8770, R²CV=0.1784
  16 components: RMSECV=3.9075, R²CV=0.1655
  17 components: RMSECV=3.9259, R²CV=0.1576
  18 components: RMSECV=3.9506, R²CV=0.1469
  19 components: RMSECV=3.9550, R²CV=0.1450
  20 components: RMSECV=3.9898, R²CV=0.1299

  Optimal components for glucose: 8
  Final R²: 0.3857, RMSE: 3.3525 g/L

============================================================
Training PLS model for Na_acetate
============================================================
   1 components: RMSECV=0.5332, R²CV=-0.1053
   2 components: RMSECV=0.5376, R²CV=-0.1238
   3 components: RMSECV=0.5270, R²CV=-0.0800
   4 components: RMSECV=0.5032, R²CV=0.0156
   5 components: RMSECV=0.5282, R²CV=-0.0846
   6 components: RMSECV=0.5444, R²CV=-0.1522
   7 components: RMSECV=0.5339, R²CV=-0.1083
   8 components: RMSECV=0.5567, R²CV=-0.2051
   9 components: RMSECV=0.5732, R²CV=-0.2773
  10 components: RMSECV=0.5949, R²CV=-0.3761
  11 components: RMSECV=0.6134, R²CV=-0.4629
  12 components: RMSECV=0.6396, R²CV=-0.5904
  13 components: RMSECV=0.6623, R²CV=-0.7056
  14 components: RMSECV=0.6793, R²CV=-0.7939
  15 components: RMSECV=0.6882, R²CV=-0.8415
  16 components: RMSECV=0.6992, R²CV=-0.9010
  17 components: RMSECV=0.7049, R²CV=-0.9317
  18 components: RMSECV=0.7113, R²CV=-0.9673
  19 components: RMSECV=0.7204, R²CV=-1.0177
  20 components: RMSECV=0.7285, R²CV=-1.0634

  Optimal components for Na_acetate: 4
  Final R²: 0.0156, RMSE: 0.5032 g/L

============================================================
Training PLS model for Mg_SO4
============================================================
   1 components: RMSECV=1.2813, R²CV=0.1234
   2 components: RMSECV=0.8643, R²CV=0.6011
   3 components: RMSECV=0.6878, R²CV=0.7474
   4 components: RMSECV=0.5916, R²CV=0.8131
   5 components: RMSECV=0.6017, R²CV=0.8067
   6 components: RMSECV=0.6490, R²CV=0.7751
   7 components: RMSECV=0.6623, R²CV=0.7658
   8 components: RMSECV=0.6818, R²CV=0.7518
   9 components: RMSECV=0.7159, R²CV=0.7263
  10 components: RMSECV=0.7463, R²CV=0.7026
  11 components: RMSECV=0.7748, R²CV=0.6794
  12 components: RMSECV=0.7860, R²CV=0.6701
  13 components: RMSECV=0.8074, R²CV=0.6519
  14 components: RMSECV=0.8163, R²CV=0.6441
  15 components: RMSECV=0.8323, R²CV=0.6301
  16 components: RMSECV=0.8413, R²CV=0.6220
  17 components: RMSECV=0.8559, R²CV=0.6088
  18 components: RMSECV=0.8697, R²CV=0.5961
  19 components: RMSECV=0.8806, R²CV=0.5859
  20 components: RMSECV=0.8913, R²CV=0.5758

  Optimal components for Mg_SO4: 4
  Final R²: 0.8131, RMSE: 0.5916 g/L</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-11-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
================================================================================
Performance Comparison: Single Multi-Output Model vs. Separate Models
================================================================================
Target          Single Model R²    Separate Model R²  R² Improvement  Single RMSE     Separate RMSE   RMSE Improvement
--------------------------------------------------------------------------------
glucose                    0.3915            0.3857        -0.0058         3.3367 g/L         3.3525 g/L        -0.0159 g/L
Na_acetate                -0.1697            0.0156        +0.1853         0.5485 g/L         0.5032 g/L        +0.0453 g/L
Mg_SO4                     0.7974            0.8131        +0.0157         0.6159 g/L         0.5916 g/L        +0.0243 g/L
================================================================================</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="raman_files/figure-html/notebooks-_ml-cell-11-output-4.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This notebook demonstrates the development of <strong>Partial Least Squares (PLS) regression models</strong> for predicting concentrations of glucose, Na_acetate, and Mg_SO4 from Raman spectra. The following summarizes key findings and decisions:</p>
<section id="preprocessing-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="preprocessing-pipeline">Preprocessing Pipeline</h3>
<p><strong>Spectral Preprocessing Steps:</strong></p>
<ol type="1">
<li><strong>Cropping</strong> to the fingerprint region (300-1942 cm⁻¹) to focus on the most informative spectral region</li>
<li><strong>Cosmic ray removal</strong> using the Whitaker-Hayes algorithm to eliminate spurious high-intensity spikes</li>
<li><strong>Savitzky-Golay smoothing</strong> (window length=9, polynomial order=3) to reduce high-frequency noise</li>
<li><strong>Baseline correction</strong> using Adaptive Smoothing Parameter Least Squares (ASPLS) to remove fluorescence background</li>
</ol>
<p><strong>Normalization:</strong></p>
<ul>
<li><strong>MinMax normalization</strong> was applied despite its limitations for regression tasks. This choice was necessary to handle high intensity variations (values reaching ~350 arbitrary units), as internal standard normalization was not feasible in this context due to the lack of a suitable reference peak.</li>
</ul>
</section>
<section id="modeling-approach" class="level3">
<h3 class="anchored" data-anchor-id="modeling-approach">Modeling Approach</h3>
<p>Two modeling strategies were compared:</p>
<p><strong>1. Single Multi-Output PLS Model</strong></p>
<ul>
<li>One PLS model predicting all three targets simultaneously</li>
<li>Optimal components: 12</li>
<li>Overall R²: 0.34, RMSE: 1.50 g/L</li>
<li>Individual performance varied significantly across targets</li>
</ul>
<p><strong>2. Separate PLS Models Per Target</strong></p>
<ul>
<li>Independent PLS models for each compound with individually optimized component counts</li>
<li><strong>Glucose</strong>: 8 components, R²: 0.39, RMSE: 3.35 g/L</li>
<li><strong>Na_acetate</strong>: 4 components, R²: 0.02, RMSE: 0.50 g/L<br>
</li>
<li><strong>Mg_SO4</strong>: 4 components, R²: 0.81, RMSE: 0.59 g/L</li>
</ul>
</section>
<section id="key-insights" class="level3">
<h3 class="anchored" data-anchor-id="key-insights">Key Insights</h3>
<ol type="1">
<li><p><strong>Separate models provide superior interpretability</strong>: Each target has its own loadings that clearly show which spectral regions are important for that specific compound, making the models more interpretable and chemically meaningful.</p></li>
<li><p><strong>Independent optimization is beneficial</strong>: Different targets require different numbers of components (8 for glucose vs.&nbsp;4 for Na_acetate and Mg_SO4), demonstrating that separate models allow for better hyperparameter tuning tailored to each compound’s spectral characteristics.</p></li>
<li><p><strong>Performance varies significantly by compound</strong>:</p>
<ul>
<li><strong>Mg_SO4</strong> shows <strong>excellent</strong> predictive performance (R² = 0.81), indicating strong, distinct spectral signatures that are easily captured by the model.</li>
<li><strong>Glucose</strong> shows <strong>moderate</strong> performance (R² = 0.39), suggesting some predictive capability but with room for improvement through feature engineering or alternative preprocessing.</li>
<li><strong>Na_acetate</strong> shows <strong>poor</strong> performance (R² ≈ 0.02), indicating weak or overlapping spectral features that may require additional preprocessing, feature selection, or alternative modeling approaches.</li>
</ul></li>
<li><p><strong>Model selection recommendation</strong>: For production use, <strong>separate PLS models per target are recommended</strong> due to their:</p>
<ul>
<li>Improved interpretability through target-specific loadings</li>
<li>Independent optimization capabilities for each compound</li>
<li>Ability to focus on compound-specific spectral regions</li>
</ul></li>
</ol>
</section>
</section>
<a class="quarto-notebook-link" id="nblink-2" href="notebooks/_ml-preview.html#0fd619c2">Source: Raman Challenge: Machine Learning Model for Concentration Prediction</a></div>
<section id="sec-pls-canonical" class="level2">
<h2 class="anchored" data-anchor-id="sec-pls-canonical">PLS Canonical (PLSW2A) Algorithm</h2>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p><a href="https://scikit-learn.org/stable/modules/cross_decomposition.html#cross-decomposition"><strong>PLS Canonical</strong></a> (also known as <strong>PLSW2A</strong>) is a method for finding low-dimensional projections of two data matrices <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> that maximize the covariance between their projected representations. Given two centered data matrices <span class="math inline">\(X \in \mathbb{R}^{n \times p}\)</span> and <span class="math inline">\(Y \in \mathbb{R}^{n \times q}\)</span>, and a desired number of latent components <span class="math inline">\(K\)</span>, the objective is to find projections that maximize shared covariance while allowing reconstruction of both <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> from latent components.</p>
<p><strong>PLS Canonical</strong> focuses on <strong>symmetric covariance maximization</strong> between <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, treating both matrices equally. This distinguishes it from <strong>PLS Regression</strong>, which focuses on <strong>predicting</strong> <span class="math inline">\(Y\)</span> from <span class="math inline">\(X\)</span>. The key algorithmic differences are:</p>
<ol type="1">
<li>In PLS Regression, the <span class="math inline">\(Y\)</span>-weight vector <span class="math inline">\(c_k\)</span> is never normalized (no unit length constraint);</li>
<li>PLS Regression regresses <span class="math inline">\(Y_{k-1}\)</span> on <span class="math inline">\(X\)</span>-scores <span class="math inline">\(t_k\)</span> instead of <span class="math inline">\(Y\)</span>-scores <span class="math inline">\(u_k\)</span>:</li>
</ol>
<p><span class="math display">\[
q_k = \frac{Y_{k-1}^\top t_k}{t_k^\top t_k} \quad \text{(PLS Regression)}
\]</span> versus: <span class="math display">\[
q_k = \frac{Y_{k-1}^\top u_k}{u_k^\top u_k} \quad \text{(PLS Canonical)}
\]</span></p>
</section>
<section id="algorithm" class="level3">
<h3 class="anchored" data-anchor-id="algorithm">Algorithm</h3>
<p>The algorithm initializes with <span class="math inline">\(X_0 = X\)</span> and <span class="math inline">\(Y_0 = Y\)</span>. For each component <span class="math inline">\(k = 1, \dots, K\)</span>, the following steps are performed iteratively.</p>
<p><strong>Step (a): Compute Weights via Covariance Maximization.</strong> Compute the cross-covariance matrix <span class="math inline">\(C_k = X_{k-1}^\top Y_{k-1}\)</span> and find the top left and right singular vectors: <span class="math display">\[
(w_k, c_k) = \arg\max_{\|w\|=\|c\|=1} w^\top C_k c
\]</span></p>
<p>These are obtained from the singular value decomposition of <span class="math inline">\(C_k\)</span>, where <span class="math inline">\(w_k \in \mathbb{R}^p\)</span> is the <span class="math inline">\(X\)</span>-weight vector and <span class="math inline">\(c_k \in \mathbb{R}^q\)</span> is the <span class="math inline">\(Y\)</span>-weight vector. These directions define projections of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> that maximize their covariance. Implementation options include full SVD of <span class="math inline">\(X_{k-1}^\top Y_{k-1}\)</span> or power iteration (NIPALS algorithm).</p>
<p><strong>Step (b): Compute Scores.</strong> Project data onto the weight vectors: <span class="math display">\[
t_k = X_{k-1} w_k \quad \in \mathbb{R}^n \quad \text{($X$-score)}
\]</span> <span class="math display">\[
u_k = Y_{k-1} c_k \quad \in \mathbb{R}^n \quad \text{($Y$-score)}
\]</span></p>
<p>Scores are the sample coordinates in the shared latent space.</p>
<p><strong>Step (c): Compute Loadings via Regression.</strong> Regress original variables onto their respective scores: <span class="math display">\[
p_k = \frac{X_{k-1}^\top t_k}{t_k^\top t_k} \quad \in \mathbb{R}^p \quad \text{($X$-loading)}
\]</span> <span class="math display">\[
q_k = \frac{Y_{k-1}^\top u_k}{u_k^\top u_k} \quad \in \mathbb{R}^q \quad \text{($Y$-loading)}
\]</span></p>
<p>Loadings indicate how each original variable contributes to the latent component and provide the best rank-1 reconstruction of the deflated data.</p>
<p><strong>Step (d): Deflation.</strong> Remove the extracted rank-1 structure: <span class="math display">\[
X_k = X_{k-1} - t_k p_k^\top
\]</span> <span class="math display">\[
Y_k = Y_{k-1} - u_k q_k^\top
\]</span></p>
<p>Deflation ensures each subsequent component captures new, orthogonal covariance structure.</p>
</section>
<section id="matrix-decompositions" class="level3">
<h3 class="anchored" data-anchor-id="matrix-decompositions">Matrix Decompositions</h3>
<p>After extracting <span class="math inline">\(K\)</span> components, we obtain low-rank approximations. For <span class="math inline">\(X\)</span>: <span class="math display">\[
X \approx T P^\top
\]</span></p>
<p>where <span class="math inline">\(T = [t_1, \dots, t_K] \in \mathbb{R}^{n \times K}\)</span> is the <span class="math inline">\(X\)</span>-score matrix and <span class="math inline">\(P = [p_1, \dots, p_K] \in \mathbb{R}^{p \times K}\)</span> is the <span class="math inline">\(X\)</span>-loading matrix. For <span class="math inline">\(Y\)</span>: <span class="math display">\[
Y \approx U Q^\top
\]</span></p>
<p>where <span class="math inline">\(U = [u_1, \dots, u_K] \in \mathbb{R}^{n \times K}\)</span> is the <span class="math inline">\(Y\)</span>-score matrix and <span class="math inline">\(Q = [q_1, \dots, q_K] \in \mathbb{R}^{q \times K}\)</span> is the <span class="math inline">\(Y\)</span>-loading matrix.</p>
</section>
<section id="rotation-matrices" class="level3">
<h3 class="anchored" data-anchor-id="rotation-matrices">Rotation Matrices</h3>
<p>During training, we compute scores iteratively on deflated data. For new data <span class="math inline">\(X_{\text{new}}\)</span>, we need a single transformation that maps directly from the original space to scores <strong>without re-running the deflation algorithm</strong>. We seek a matrix <span class="math inline">\(R_x \in \mathbb{R}^{p \times K}\)</span> such that <span class="math inline">\(T = X R_x\)</span>, and then for new data: <span class="math inline">\(T_{\text{new}} = X_{\text{new}} R_x\)</span>.</p>
<p>One might expect <span class="math inline">\(T = XW\)</span> where <span class="math inline">\(W = [w_1, \dots, w_K]\)</span>, but this is <strong>incorrect</strong> after the first component because each <span class="math inline">\(w_k\)</span> was computed on <strong>deflated data</strong> <span class="math inline">\(X_{k-1}\)</span> while <span class="math inline">\(X\)</span> is the <strong>original, undeflated data</strong>. Deflation breaks the direct relationship between weights and scores, so <span class="math inline">\(XW \neq T\)</span> in general.</p>
<p>From the decomposition <span class="math inline">\(X \approx TP^\top\)</span>, multiply both sides by <span class="math inline">\(W\)</span>: <span class="math inline">\(XW \approx TP^\top W\)</span>. Since <span class="math inline">\(P^\top W \in \mathbb{R}^{K \times K}\)</span> is invertible in PLS Canonical, we have <span class="math inline">\(T = XW(P^\top W)^{-1}\)</span>. Define the <strong><span class="math inline">\(X\)</span>-rotation matrix</strong>: <span class="math display">\[
R_x = W(P^\top W)^{-1}
\]</span></p>
<p>Then <span class="math inline">\(T = XR_x\)</span>. The dimensions are: <span class="math display">\[
X \in \mathbb{R}^{n \times p}, \quad W \in \mathbb{R}^{p \times K}, \quad P \in \mathbb{R}^{p \times K}, \quad P^\top W \in \mathbb{R}^{K \times K}, \quad R_x \in \mathbb{R}^{p \times K}, \quad T \in \mathbb{R}^{n \times K}.
\]</span></p>
<p>Intuitively, <span class="math inline">\(W\)</span> provides “raw” projections based on deflated data, <span class="math inline">\((P^\top W)^{-1}\)</span> corrects for interference between components, and <span class="math inline">\(R_x\)</span> gives the equivalent direct projection from original space.</p>
<p>By identical reasoning, from <span class="math inline">\(Y \approx UQ^\top\)</span>: <span class="math inline">\(U = YC(Q^\top C)^{-1}\)</span>. Define the <strong><span class="math inline">\(Y\)</span>-rotation matrix</strong>: <span class="math display">\[
R_y = C(Q^\top C)^{-1}
\]</span></p>
<p>where <span class="math inline">\(C = [c_1, \dots, c_K] \in \mathbb{R}^{q \times K}\)</span>. Then <span class="math inline">\(U = YR_y\)</span>. In scikit-learn, <code>x_rotations_</code> stores <span class="math inline">\(R_x\)</span> and <code>y_rotations_</code> stores <span class="math inline">\(R_y\)</span>. Geometrically, rotation matrices re-embed the sequential deflation process into a single linear transformation in the original space.</p>
</section>
<section id="prediction-mapping-x-to-y" class="level3">
<h3 class="anchored" data-anchor-id="prediction-mapping-x-to-y">Prediction: Mapping <span class="math inline">\(X\)</span> to <span class="math inline">\(Y\)</span></h3>
<p>The objective is to find a coefficient matrix <span class="math inline">\(B \in \mathbb{R}^{p \times q}\)</span> such that <span class="math inline">\(\hat{Y} = XB\)</span>. The prediction follows a three-stage pipeline through the latent space.</p>
<ol type="1">
<li><strong>Stage 1: <span class="math inline">\(X\)</span> to <span class="math inline">\(X\)</span>-scores</strong> uses <span class="math inline">\(T = XR_x\)</span>.</li>
<li><strong>Stage 2: <span class="math inline">\(X\)</span>-scores to <span class="math inline">\(Y\)</span>-scores (latent regression)</strong> models the relationship between latent scores as <span class="math inline">\(U \approx TG\)</span>, where <span class="math inline">\(G \in \mathbb{R}^{K \times K}\)</span> is obtained via least squares: <span class="math display">\[
G = (T^\top T)^{-1}T^\top U
\]</span></li>
<li><strong>Stage 3: <span class="math inline">\(Y\)</span>-scores to <span class="math inline">\(Y\)</span> (reconstruction)</strong> uses the decomposition <span class="math inline">\(Y \approx UQ^\top\)</span> to get <span class="math inline">\(\hat{Y} = UQ^\top\)</span>. Combining all stages: <span class="math display">\[
\hat{Y} = XR_x \cdot G \cdot Q^\top
\]</span> Therefore, the coefficient matrix is: <span class="math display">\[
B = R_x G Q^\top
\]</span> In scikit-learn, this is stored in the <code>coef_</code> attribute. The pipeline summary is: <span class="math display">\[
X \xrightarrow{R_x} T \xrightarrow{G} U \xrightarrow{Q^\top} \hat{Y}
\]</span></li>
</ol>
</section>
<section id="summary-table-1" class="level3">
<h3 class="anchored" data-anchor-id="summary-table-1">Summary Table</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 21%">
<col style="width: 29%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th>Concept</th>
<th>Symbol</th>
<th>Dimension</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Weights</strong></td>
<td><span class="math inline">\(W, C\)</span></td>
<td><span class="math inline">\(p \times K\)</span>, <span class="math inline">\(q \times K\)</span></td>
<td>Directions of maximal shared covariance</td>
</tr>
<tr class="even">
<td><strong>Scores</strong></td>
<td><span class="math inline">\(T, U\)</span></td>
<td><span class="math inline">\(n \times K\)</span></td>
<td>Latent representations of samples</td>
</tr>
<tr class="odd">
<td><strong>Loadings</strong></td>
<td><span class="math inline">\(P, Q\)</span></td>
<td><span class="math inline">\(p \times K\)</span>, <span class="math inline">\(q \times K\)</span></td>
<td>Reconstruction directions</td>
</tr>
<tr class="even">
<td><strong>Rotations</strong></td>
<td><span class="math inline">\(R_x, R_y\)</span></td>
<td><span class="math inline">\(p \times K\)</span>, <span class="math inline">\(q \times K\)</span></td>
<td>Direct projection from original to latent space</td>
</tr>
<tr class="odd">
<td><strong>Coefficients</strong></td>
<td><span class="math inline">\(B\)</span></td>
<td><span class="math inline">\(p \times q\)</span></td>
<td>Prediction map <span class="math inline">\(X \to Y\)</span> via latent space</td>
</tr>
</tbody>
</table>
<p>The core equations are:</p>
<p><strong>Scores from original data:</strong> <span class="math display">\[
T = XR_x, \quad U = YR_y
\]</span> <strong>Decompositions:</strong> <span class="math display">\[
X \approx TP^\top, \quad Y \approx UQ^\top
\]</span> <strong>Prediction:</strong> <span class="math display">\[
\hat{Y} = XB \quad \text{where} \quad B = R_xGQ^\top
\]</span></p>



</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-EilersALS2005" class="csl-entry" role="listitem">
Eilers, Paul H. C., and Hans F. M. Boelens. 2005. <span>“Baseline Correction with Asymmetric Least Squares Smoothing.”</span> 1. Leiden University Medical Centre.
</div>
<div id="ref-georgiev2024ramanspy" class="csl-entry" role="listitem">
Georgiev, Dimitar, Simon Vilms Pedersen, Ruoxiao Xie, Alvaro Fernández-Galiana, Molly M Stevens, and Mauricio Barahona. 2024. <span>“RamanSPy: An Open-Source Python Package for Integrative Raman Spectroscopy Data Analysis.”</span> <em>Analytical Chemistry</em> 96 (21): 8492–8500. <a href="https://doi.org/10.1021/acs.analchem.4c00383">https://doi.org/10.1021/acs.analchem.4c00383</a>.
</div>
<div id="ref-dig-4-bio-raman-transfer-learning-challenge" class="csl-entry" role="listitem">
Hassfurther, Rosa. 2025. <span>“Dig4Bio Raman Transfer Learning Challenge.”</span> <a href="https://kaggle.com/competitions/dig-4-bio-raman-transfer-learning-challenge">https://kaggle.com/competitions/dig-4-bio-raman-transfer-learning-challenge</a>.
</div>
<div id="ref-LANGE2025125861" class="csl-entry" role="listitem">
Lange, Christoph, Maxim Borisyak, Martin Kögler, Stefan Born, Andreas Ziehe, Peter Neubauer, and M. Nicolas Cruz Bournazou. 2025. <span>“Comparing Machine Learning Methods on Raman Spectra from Eight Different Spectrometers.”</span> <em>Spectrochimica Acta Part A: Molecular and Biomolecular Spectroscopy</em> 334: 125861. https://doi.org/<a href="https://doi.org/10.1016/j.saa.2025.125861">https://doi.org/10.1016/j.saa.2025.125861</a>.
</div>
<div id="ref-SavitzkyGolay1964" class="csl-entry" role="listitem">
Savitzky, Abraham, and Marcel J. E. Golay. 1964. <span>“Smoothing and Differentiation of Data by Simplified Least Squares Procedures.”</span> <em>Analytical Chemistry</em> 36 (8): 1627–39. <a href="https://doi.org/10.1021/ac60214a047">https://doi.org/10.1021/ac60214a047</a>.
</div>
<div id="ref-WhitakerHayes2018" class="csl-entry" role="listitem">
Whitaker, Daniel A., and Kevin Hayes. 2018. <span>“A Simple Algorithm for Despiking Raman Spectra.”</span> <em>Chemometrics and Intelligent Laboratory Systems</em> 179: 82–84. <a href="https://doi.org/10.1016/j.chemolab.2018.06.009">https://doi.org/10.1016/j.chemolab.2018.06.009</a>.
</div>
<div id="ref-wikipedia-raman-spectroscopy" class="csl-entry" role="listitem">
Wikipedia contributors. 2025. <span>“Raman Spectroscopy.”</span> <a href="https://en.wikipedia.org/w/index.php?title=Raman_spectroscopy&amp;oldid=1328445745">https://en.wikipedia.org/w/index.php?title=Raman_spectroscopy&amp;oldid=1328445745</a>.
</div>
<div id="ref-ZhangASPLS2010" class="csl-entry" role="listitem">
Zhang, Zhi-Min, Shan Chen, and Yi-Zeng Liang. 2010. <span>“Baseline Correction Using Adaptive Iteratively Reweighted Penalized Least Squares.”</span> <em>Analyst</em> 135 (5): 1138–46. <a href="https://doi.org/10.1039/B922045C">https://doi.org/10.1039/B922045C</a>.
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{brosse2026,
  author = {Brosse, Nicolas},
  title = {Analyzing {Raman} {Spectra} with {Machine} {Learning}},
  date = {2026-01-18},
  url = {https://nbrosse.github.io/posts/raman/raman.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-brosse2026" class="csl-entry quarto-appendix-citeas" role="listitem">
Brosse, Nicolas. 2026. <span>“Analyzing Raman Spectra with Machine
Learning.”</span> January 18, 2026. <a href="https://nbrosse.github.io/posts/raman/raman.html">https://nbrosse.github.io/posts/raman/raman.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/nbrosse\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>